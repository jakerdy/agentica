---
name: agentica.reverse
description: Реверс-инжиниринг существующего кода с созданием архитектурной спецификации
---

## Ввод пользователя

```text
$ARGUMENTS
```

Ты **ОБЯЗАН** учесть ввод пользователя (аргументы и контекст) перед тем как продолжить.

## Цель и принципы работы

Твоя задача — проанализировать существующую кодовую базу и создать архитектурную спецификацию "As-Is", описывающую **реальное** состояние системы.
Работай строго линейно: **Валидация → Сканирование → Анализ → Выявление проблем → Создание → Проверка → Отчёт**.

Реверс-инжиниринг — это **документирование существующего**, а не проектирование нового. Ты восстанавливаешь карту того, что уже написано, подсвечиваешь архитектурный долг и риски.

### Глобальные запреты (Safety Guards)

Останови выполнение и не вноси изменения, если:
1. Запрос требует **изменения кода** или рефакторинга (используй `refactor` или `change`).
2. Запрос описывает **новую систему**, которой ещё нет (используй `architect`).
3. Код отсутствует или директория пуста (нечего анализировать).
4. Запрос касается только **одного файла** или **одной функции** (слишком узкий скоуп для архитектурного анализа).
5. Пользователь просит написать новую фичу на основе анализа (сперва завершить reverse, затем использовать `create`).

В случае остановки: объясни причину и предложи корректную команду.

## 1. Топология и размещение файлов

Результат реверс-инжиниринга сохраняется как обычная архитектурная спецификация в `.agentica/architecture/`:
- **Single-project:** `./.agentica/architecture/`
- **Monorepo (package):** `./packages/<name>/.agentica/architecture/`

**Формат имени файла:** `AR-XXXX - <Название системы> (As-Is).md`
- `XXXX` — четырехзначный номер, определяется автоматически (следующий свободный).
- `<Название системы>` — краткое описание анализируемой области.
- Суффикс `(As-Is)` — обязателен, подчеркивает, что это описание существующего состояния.

Примеры:
- `AR-0005 - Система авторизации (As-Is).md`
- `AR-0018 - Модуль обработки событий (As-Is).md`
- `AR-0027 - Архитектура монорепо (As-Is).md`

## 2. Фаза 1: Валидация контекста и определение скоупа

### Шаг 1.1: Определение скоупа анализа
1. Прочитай `structure.md` из корня проекта.
2. Определи тип проекта: Single-project или Monorepo.
3. Определи **область анализа**:
   - Если пользователь указал конкретный модуль/пакет → анализируй его.
   - Если указал "весь проект" → анализируй всю кодовую базу.
   - Если не указал, но контекст очевиден (открытая директория) → используй её.
   - Если неоднозначно → задай вопрос через `askQuestion`.

### Шаг 1.2: Чтение контекста проекта
Прочитай следующие файлы из целевого скоупа (если существуют):
1. `product.md` — продуктовый контекст.
2. `structure.md` — заявленная структура проекта.
3. `tech.md` — технический стек и стандарты.
4. Список существующих файлов в `architecture/` (для определения номера AR-XXXX и избежания дублирования).

### Шаг 1.3: Определение глубины анализа

Задай пользователю вопрос (если не очевидно из контекста):

**Какая глубина анализа требуется?**
- **Обзорная (High-level):** Общая структура, модули, зависимости. Без погружения в детали реализации.
- **Детальная (Deep-dive):** Полный анализ с интерфейсами, паттернами, алгоритмами и кодовыми проблемами.
- **Целевая (Focused):** Глубокий анализ конкретной области (например, "только система кэширования").

По умолчанию используй **Обзорную**, если не указано иное.

## 3. Фаза 2: Сканирование кодовой базы

### Шаг 2.1: Построение карты модулей

Используй `semantic_search` и `file_search` для сбора информации:
1. **Entry points:** Найди точки входа (main.ts, index.ts, app.py, __init__.py).
2. **Модули:** Выяви основные директории и их назначение (src/, lib/, services/, utils/).
3. **Зависимости:** Прочитай package.json / pyproject.toml / requirements.txt.
4. **Конфигурация:** Найди конфигурационные файлы (config/, .env, tsconfig.json).

### Шаг 2.2: Анализ зависимостей между модулями

Для каждого ключевого модуля:
1. Найди все `import` / `require` / `from X import` в файлах.
2. Построй граф зависимостей (кто от кого зависит).
3. Выяви **циклические зависимости** (A → B → C → A).
4. Найди **монолитные файлы** (> 300 строк) и **God Objects** (классы с > 10 методами разной ответственности).

### Шаг 2.3: Выявление паттернов и практик

Анализируй код на предмет:
1. **Используемые паттерны:** Factory, Singleton, Observer, Dependency Injection и т.д.
2. **Архитектурный стиль:** Layered, Microservices, Event-Driven, Monolith.
3. **Соглашения по коду:** Naming conventions, структура файлов, группировка логики.

## 4. Фаза 3: Анализ и выявление проблем

### Шаг 3.1: Архитектурный долг (Technical Debt)

Ищи маркеры технического долга:
1. **TODO / FIXME / HACK комментарии:** Соберы все упоминания и категоризируй.
2. **Дублирование кода:** Повторяющиеся паттерны в 3+ местах без переиспользования.
3. **Мёртвый код:** Неиспользуемые функции, классы, импорты (проверь через поиск ссылок).
4. **Нарушение принципов:**
   - **SRP:** Классы с несколькими ответственностями.
   - **DRY:** Копипаста логики.
   - **YAGNI:** Переусложнение без необходимости.

### Шаг 3.2: Узкие места и риски

Выяви проблемы производительности и стабильности:
1. **Синхронные блокировки:** Долгие синхронные операции в async окружении.
2. **N+1 проблемы:** Циклы с запросами в БД/API без батчинга.
3. **Отсутствие обработки ошибок:** Try-catch отсутствует или catch игнорирует ошибки.
4. **Хардкод:** Магические числа, жестко зашитые URL, credentials в коде.
5. **Отсутствие тестов:** Критичная логика без unit/integration тестов.

### Шаг 3.3: Нарушения стандартов проекта

Сверь код с `tech.md`:
- Используются ли запрещённые библиотеки?
- Соблюдаются ли соглашения по именованию?
- Есть ли отклонения от заявленного стека?

## 5. Фаза 4: Интервью с пользователем (опционально)

### Когда запускать интервью

Задавай вопросы, если:
1. Обнаружены неоднозначные архитектурные решения (например, смешение паттернов).
2. Найдены критичные проблемы, требующие подтверждения (например, "это баг или фича?").
3. Требуется понимание **истории решений** ("почему сделано именно так?").

### Вопросы для уточнения

Группируй вопросы по 2-3, не перегружай:
1. **История:** Почему выбран такой подход? Были ли альтернативы?
2. **Приоритеты:** Что важнее: совместимость с legacy или рефакторинг?
3. **Проблемы:** Какие известные баги или ограничения существуют?
4. **Планы:** Есть ли планы по изменению архитектуры?

Если пользователь не может ответить (нет знаний о проекте) — задокументируй **предположения** и пометь их как "(Assumed)".

## 6. Фаза 5: Создание архитектурного документа

### Структура документа (As-Is специфика)

Адаптируй разделы под результаты анализа. Обязательные разделы: 1, 2, 3, 6, 7.

```markdown
# AR-XXXX - <Название системы> (As-Is)

> **Тип документа:** Реверс-инжиниринг  
> **Дата анализа:** YYYY-MM-DD  
> **Скоуп:** [путь к анализируемой области]  
> **Глубина:** [Обзорная / Детальная / Целевая]

## 1. Краткое описание (Executive Summary)

**Что это:** 2-3 предложения о назначении системы/модуля.

**Основные компоненты:** Список из 3-5 ключевых модулей с кратким описанием.

**Общее состояние:** [Хорошее / Удовлетворительное / Требует внимания / Критическое]

## 2. Архитектурный стиль и паттерны

### Общий стиль
Описание архитектуры в терминах (выбери применимые):
- **Monolith** / **Modular Monolith** / **Microservices**
- **Layered** / **Hexagonal** / **Event-Driven**
- **MVC** / **MVVM** / **Clean Architecture**

### Используемые паттерны
Список обнаруженных паттернов с примерами из кода:
- **Factory Pattern:** `UserFactory.create()` в `src/factories/user.ts`
- **Singleton:** `ConfigManager` через static instance в `src/config.ts`

### Отклонения от паттернов
Места, где паттерны нарушены или смешаны:
- В `ServiceA` используется DI, а в `ServiceB` — прямое создание зависимостей.

## 3. Структура и модули

### Карта модулей

```
src/
├── core/           # Основная бизнес-логика (Entities, Use Cases)
│   ├── entities/   # Модели данных
│   └── services/   # Бизнес-сервисы
├── api/            # HTTP handlers (Express routes)
├── database/       # Репозитории и миграции
├── utils/          # Утилиты (валидация, логирование)
└── config/         # Конфигурационные файлы
```

### Основные модули

Для каждого ключевого модуля:

#### 3.1 Модуль: `core/services`
- **Назначение:** Бизнес-логика обработки заказов.
- **Ключевые файлы:** `OrderService.ts`, `PaymentService.ts`.
- **Зависимости:** `database/repositories`, `utils/validators`.
- **Проблемы:** Циклическая зависимость между OrderService и PaymentService.

## 4. Интерфейсы и контракты

Список публичных API/интерфейсов:

### 4.1 API Endpoints (если применимо)
```
GET    /api/orders         - Список заказов
POST   /api/orders         - Создание заказа
PATCH  /api/orders/:id     - Обновление статуса
```

### 4.2 Публичные классы/функции
- **`OrderService.createOrder(data: OrderDTO): Promise<Order>`**
  - Параметры: `OrderDTO` (user_id, items, total)
  - Возвращает: `Order` entity
  - Побочные эффекты: Запись в БД, отправка email

## 5. Потоки данных (Data Flow)

ASCII-диаграмма или описание основных сценариев:

### Сценарий: Создание заказа
```
Client (POST /orders)
   ↓
OrderController
   ↓ validate
OrderValidator
   ↓ create
OrderService
   ↓ save          ↓ send event
OrderRepository   EventBus
   ↓                 ↓
Database          EmailService
```

## 6. Зависимости и библиотеки

### Внешние библиотеки
Таблица с анализом:

| Библиотека | Версия | Назначение | Статус |
|:-----------|:-------|:-----------|:-------|
| express    | 4.18.x | HTTP сервер | Актуальная |
| lodash     | 3.10.x | Утилиты     | ⚠️ Устаревшая (есть 4.x) |
| moment     | 2.29.x | Даты        | ⛔ Deprecated (use date-fns) |

### Внутренние зависимости
Граф зависимостей между модулями:
```
core/services → database/repositories → core/entities
api/controllers → core/services
utils/* ← (используется всеми)
```

**Циклические зависимости:**
- `OrderService` ↔ `PaymentService` (через взаимные импорты)

## 7. Проблемы и архитектурный долг

### 7.1 Критичные проблемы (блокирующие)
| Проблема | Локация | Влияние | Рекомендация |
|:---------|:--------|:--------|:-------------|
| Отсутствие обработки ошибок при сбое БД | OrderService.ts:45 | Высокое | Добавить try-catch и retry-логику |
| Хардкод API ключей в коде | PaymentService.ts:12 | Критическое | Вынести в переменные окружения |

### 7.2 Технический долг (требует внимания)
- **Дублирование:** Валидация email повторяется в 5+ местах без переиспользования.
- **Монолитные файлы:** `UserService.ts` (450 строк) содержит 3 разные ответственности.
- **Мёртвый код:** Функция `legacyParser()` не используется нигде (последнее использование удалено в коммите abc123).

### 7.3 TODO и FIXME (отложенные работы)
- `// TODO: Добавить кэширование` — найдено в 7 файлах.
- `// FIXME: Временный хак, исправить до релиза` — в `core/services/order.ts:89` (код 2 года).
- `// HACK: Обходим баг в библиотеке X` — в `utils/parser.ts:23`.

## 8. Нарушения стандартов проекта

Сравнение с `tech.md`:
- **Заявлено:** "Использовать Winston для логирования"  
  **Реально:** В 40% файлов используется `console.log`.
  
- **Заявлено:** "Избегать глобального состояния"  
  **Реально:** `ConfigManager` реализован как Singleton с мутабельным состоянием.

## 9. Производительность и узкие места

### Потенциальные bottlenecks
- **N+1 запросы:** В `OrderController.list()` для каждого заказа идёт отдельный запрос к БД за пользователем.
- **Синхронные блокировки:** Чтение файлов через `fs.readFileSync()` блокирует event loop.
- **Отсутствие кэширования:** Справочники загружаются из БД при каждом запросе.

### Отсутствие тестов
Покрытие тестами (по результатам анализа):
- **Unit тесты:** < 20% (только для `utils/validators`)
- **Integration тесты:** Отсутствуют
- **E2E тесты:** Отсутствуют

## 10. Качество кода

### Позитивные практики
- Использование TypeScript с strict mode.
- Чёткое разделение на слои (controllers, services, repositories).
- Наличие конфигурации ESLint и Prettier.

### Проблемные практики
- Смешение async/await и callbacks в одном файле.
- Неконсистентная обработка ошибок (где-то throw, где-то return null).
- Отсутствие JSDoc для публичных API.

## 11. Рекомендации по улучшению

### Краткосрочные (Quick Wins)
1. **Исправить хардкод credentials:** Вынести в .env (1-2 часа работы).
2. **Убрать циклическую зависимость OrderService ↔ PaymentService:** Создать промежуточный слой или событийную модель (4-6 часов).
3. **Обновить устаревшие библиотеки:** lodash 3→4, moment→date-fns (2-3 часа + тестирование).

### Среднесрочные (1-2 спринта)
1. **Рефакторинг монолитных файлов:** Разделить `UserService` на 3 отдельных сервиса.
2. **Добавить слой кэширования:** Внедрить Redis для справочников и частых запросов.
3. **Написать тесты:** Покрыть критичную бизнес-логику unit-тестами (цель: >60%).

### Долгосрочные (архитектурные)
1. **Мигрировать на Event-Driven архитектуру:** Развязать жёсткие связи между сервисами через Event Bus.
2. **Внедрить Dependency Injection:** Упростить тестирование и управление зависимостями.
3. **Создать API Gateway:** Унифицировать обработку запросов, добавить rate limiting и аутентификацию на едином слое.

## 12. Дополнительные материалы

### Диаграммы зависимостей
(Если применимо — добавь Mermaid/ASCII диаграммы)

### Метрики кода
- **Всего файлов:** 127
- **Строк кода:** ~15,000
- **Средняя сложность (Cyclomatic):** 8.5 (цель: <10)
- **Самый сложный файл:** `OrderService.ts` (complexity: 24)

### История изменений
(Если проводился повторный анализ)
- **2025-12-10:** Первичный анализ
- **2026-02-16:** Обновление после рефакторинга модуля авторизации
```

### Требования к качеству содержания

1. **Факты, не мнения:** Каждое утверждение должно быть подтверждено ссылкой на код (файл:строка).
2. **Конкретика:** Вместо "медленно" пиши "O(n²) алгоритм в цикле из 1000+ элементов".
3. **Приоритизация:** Разделяй проблемы на критичные, важные и косметические.
4. **Actionable рекомендации:** Не "улучшить код", а "вынести функцию X в utils/auth.ts и переиспользовать".

## 7. Фаза 6: Финальная проверка

Перед сохранением файла проверь:
1. Номер AR-XXXX уникален и файл содержит суффикс `(As-Is)`.
2. В разделе "Проблемы и архитектурный долг" есть **конкретные ссылки на код** (файл:строка).
3. Рекомендации разделены на краткосрочные / среднесрочные / долгосрочные.
4. Все утверждения базируются на **реальном анализе кода**, а не на предположениях.
5. Если использовались предположения — они явно помечены как "(Assumed)".

Если хотя бы одна проверка провалена — **дополни документ** перед сохранением.

## 8. Фаза 7: Отчёт пользователю

Выдай короткое резюме:
1. **Созданный файл:** `AR-XXXX - <Название> (As-Is).md`.
2. **Скоуп анализа:** [Single-project / Monorepo / Package name].
3. **Глубина:** [Обзорная / Детальная / Целевая].
4. **Общее состояние:** [Хорошее / Удовлетворительное / Требует внимания / Критическое].
5. **Ключевые находки:** 
   - Критичные проблемы: [N шт.]
   - Технический долг: [N шт.]
   - Циклические зависимости: [N шт.]
6. **Главные рекомендации:** [Top 3 действия по приоритету].
7. **Следующий шаг:** 
   - Если нужен план улучшений → `/agentica.architect --name Рефакторинг <системы>`.
   - Если нужно исправить конкретное → `/agentica.change --name <проблема>`.

## 9. Дополнительные правила

### Работа с большими проектами
Если проект содержит > 50 файлов:
1. Начни с **обзорного анализа** (top-level модули, entry points).
2. Предложи пользователю выбрать **приоритетные области** для глубокого анализа.
3. Создай несколько As-Is документов (по одному на модуль), а не один гигантский.

### Работа с легаси-кодом
Если код старый (> 3 лет без изменений):
1. Отметь **устаревшие паттерны** (например, callback hell вместо async/await).
2. Проверь **актуальность зависимостей** (security vulnerabilities через `npm audit` / `pip audit`).
3. Подсветь **несовместимость с современными стандартами** (например, CommonJS вместо ESM).

### Объективность анализа
Избегай субъективных оценок:
- ❌ "Код написан плохо"
- ✅ "Функция `parseData()` содержит 8 уровней вложенности (рекомендуется < 4)"

### Терминология
Используй общепринятые термины:
- **Code Smell** — признак потенциальной проблемы.
- **Technical Debt** — осознанные компромиссы, требующие возврата.
- **Architectural Drift** — отклонение от заявленной архитектуры.
- **Cyclomatic Complexity** — метрика сложности кода.