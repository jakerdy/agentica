# Agentica

**Spec Driven фреймворк для агентного кодинга.**
Вдохновлен SpecKit, но исповедует Developer-first подход.

В то время как другие инструменты работают в пространстве "продукта" (User Stories, Vibe Coding), Agentica работает в пространстве "архитектора", предоставляя разработчику полный контроль над структурой и качеством кода до того, как AI напишет первую строчку.

## Quick Start

```bash
# Установка глобально
npm install -g @jakerdy/agentica

# Инициализация (работает и в пустой папке, и в существующем проекте)
agentica init --name MyProject --stack typescript/cli

# Открытие в VSCode
cd MyProject
code .
```

## Мотивация

Agentica был создан в ходе мучительного поиска "идеального" инструмента для работы с агентными системами.

На момент начала 2026 года существует множество инструментов, чтобы держать агента в рамках. Но большинство из них исходит из непростительно оптимистичного предположения, что агентная система:
1. Достаточно умна, чтобы писать качественный код.
2. Может самостоятельно построить адекватную архитектуру.
3. Позволяет пользователю быть "менеджером", который вообще не думает про структуру кода.

Однако практика показывает, что это ложь. Агентный кодинг обычно представляет собой одно из двух:
- **Цикл бесконечной борьбы**, в котором вы раз за разом затыкаете дыры в реализации, получая в итоге качество кода "ниже среднего".
- **Адская бюрократия**, требующая составления спецификации на пару тысяч строк Markdown с постоянной вычиткой и невозможностью вернуться назад без переписывания половины текста.

Но у агентов есть одно свойство, которое сложно игнорировать - они способны выдавать **очень много кода за единицу времени**. Чтобы это было полезно, им нужна правильная спека.
Agentica - это конструктор таких спек. Она заполняет расстояние между вашими архитектурными решениями и финальным кодом.


### Всадники апокалипсиса агентного кодинга

Фреймворк спроектирован для обхода четырех главных ограничений LLM:

1.  **Контекст модели ограничен.** То, что помнит модель - это 1/10 или 1/20 часть проекта. Наша задача - сделать так, чтобы в контекст попало только то, что действительно важно для задачи, и ссылки на то, куда нужно "сходить".
2.  **Context Rot (Гниение контекста).** Чем больше данных, тем глупее модель (на 5-15%). Поэтому чем уже скоуп спецификации и "общих файлов", тем лучше результат.
3.  **Context Compaction.** При переполнении агент начинает сжимать информацию, выкидывая детали. Проблема в том, что он может выкинуть важное. Мы должны либо помещаться в одну сессию, либо заставлять модель перечитывать важное.
4.  **Говнокод.** Модели обучались на GitHub. Беда в том, что в среднем люди пишут спагетти-код.
    - Молодой разработчик неопытен, пишет переусложненный код и радостно выкладывает его в OpenSource - это идеальный корм для обучения моделей.
    - Дядьки с опытом 15+ лет сидят в своих уютненьких банках, страховых и FAANG'ах. Им давно не нужно ничего контрибутить в OpenSource.
    - **Итог:** Есть явный bias модели в сторону кода сомнительного качества. Агент скорее напишет 100 строк 10-этажных вложенных конструкций, чем разделит это на плоские функции.

## Философия подхода

### 1. Тех-Задание + Продукт = Баланс

Все Spec-Driven фреймворки (которые я видел) исходят из того, что продукт первичен ("Vibe Coding"). Мы опираемся на "ощущения", а не на техническую красоту.

- Думать только о продукте = коллекционирование тех-долга с первого дня.
- Думать только о технике = постройка никому не нужного космолета.

Нужно приземлиться посередине. Агент через 100k токенов всё забудет, а код, который он написал, станет **вашей проблемой**. Поэтому ответственность должна начинаться до того, как агент начнет писать. Вы должны придумать архитектуру. Агенту останется только "заполнить тело методов".

В Agentica мы работаем сразу над "продуктовой" и "технической" частью. Например, в базовых структурах (кеши, фабрики) продукта нет - там чистая инженерия. А в новой панели GUI техничка простая, но важен UX.

### 2. Узкий Scope и Модульность
Вместо одного огромного контекста Agentica внедряет директорию `.agentica/` в каждый пакет монорепозитория. Это позволяет:
- Держать в контексте LLM только правила конкретного модуля.
- Использовать 20 файлов по 40 строк вместо одного на 1000.

### 3. Anti-Spaghetti Метод
В файле `AGENTS.md` и промптах мы перечисляем всё то, что нам *не нравится* в коде агента, и дополняем это "хорошими практиками". Мы редактируем этот список до тех пор, пока код не станет "совсем хорошим".

### 4. Семантическая валидация
Review'ить код, написанный AI - то ещё удовольствие.
Для этого нужен отдельный процесс: **Семантическая Валидация**. Агент сам ходит по коду и сверяет его с продуктовыми и техническими требованиями, выступая в роли придирчивого сеньора.

## Структура проекта

Agentica строго разделяет уровни ответственности.

### Топология файлов

- **Root проекта:** Шаблоны, промпты, глобальный контекст.
- **Package root:** Фичи, изменения, архитектура пакета.

```text
.
├── .agentica/                  # GLOBAL SCOPE (Конфигурация и общие знания)
│   ├── templates/              # Шаблоны (feature, arch, change)
│   ├── prompts/                # Промпты (init, create, implement...)
│   ├── product.md              # Глобальный продукт
│   ├── structure.md            # Структура репозитория
│   ├── tech.md                 # Глобальный стек и стандарты
│   └── status.md               # Статус интеграции в корне
├── packages/
│   ├── package1/
│   │   ├── .agentica/          # PACKAGE SCOPE (Спецификации и локальный контекст)
│   │   │   ├── architecture/   # AR-XXXX (Архитектурные решения)
│   │   │   ├── changes/        # CH-XXXX (Изменения существующего)
│   │   │   ├── features/       # FT-XXXX (Новые фичи)
│   │   │   ├── product.md      # Контекст пакета
│   │   │   ├── structure.md    # Структура пакета
│   │   │   ├── tech.md         # Стек пакета
│   │   │   └── status.md       # Статус интеграции пакета
│   │   ├── src/
│   │   └── ...
└── ...
```

**Важно:** В Single-project структуре списки объединяются в одной корневой `.agentica/`.

## Справочник команд

Все команды вызываются через `/agentica.<command>`. Аргументы опциональны - агент постарается вывести их из контекста, но явное указание надежнее.

| Команда     | Аргументы | Назначение                                            |
| :---------- | :-------- | :---------------------------------------------------- |
| `init`      | `--lang`, | Инициализация и настройка проекта                     |
| `create`    | `--name`  | Спецификация новой фичи (`FT-XXXX`)                   |
| `change`    | `--name`  | Спецификация изменений (`CH-XXXX`)                    |
| `architect` | `--name`  | Архитектурная спека / Reverse Engineering (`AR-XXXX`) |
| `iterate`   | `--id`    | Правки спеки через диалог с AI                        |
| `tasks`     | `--id`    | Декомпозиция спеки на задачи                          |
| `implement` | `--id`    | Написание кода по задачам                             |
| `validate`  | `--id`    | Семантическая и техническая приемка                   |
| `readme`    | `--id`    | Генерация документации                                |
| `refactor`  | ---       | Улучшение кода без смены API                          |

---

## Рабочие процессы (Workflows)

Ниже описаны типовые циклы разработки (Loops).

### Общие советы (Pain-killers)

- **Новая фича - новый чат.** Нам нужен максимально пустой и чистый контекст.
- **Не спасайте спеку.** Если что-то не получилось и вы хотите всё поменять в середине - удаляйте спеку, создавайте новый чат. Не пытайтесь "вылечить" текущую сессию. Вы потратите в 3 раза больше времени, а результат будет хуже. Выбрасывайте смелее.
- **Учитесь писать на русском.** Если вы не можете чётко сформулировать мысли текстом так, чтобы понял ваш товарищ, агент вас точно не поймёт. "Ну это же очевидно" для агента не работает. Спросите у LLM, как писать хорошие технические тексты - это прокачает ваш скилл промптинга.


### 1. Zero-to-Hero (Инициализация)

```text
/agentica.init --lang TypeScript
Сделай CLI для импорта CSV. Нужны команды import, validate.
Используй commander и chalk.
```
*Что происходит:* Агент создает структуру `.agentica/`, заполняет `tech.md` и `structure.md` под ваш запрос, готовит промпты.

### 2. Разработка новой фичи (Feature Loop)

Цикл: **Spec → Iterate → Tasks → Implement → Validate**.

1.  **Создание черновика:**
    ```text
    /agentica.create --name Пакетная загрузка
    Нужна загрузка CSV из папки, фильтр по маске и отчет об ошибках.
    ```
2.  **Уточнение (Iterate):**
    ```text
    /agentica.iterate --id FT-0012
    Добавь ограничение файла до 100MB и retry при ошибках сети.
    ```
3.  **План работ:**
    ```text
    /agentica.tasks --id FT-0012
    ```
4.  **Кодинг:**
    ```text
    /agentica.implement --id FT-0012
    ```
5.  **Приемка:**
    ```text
    /agentica.validate --id FT-0012
    ```

### 3. Изменение существующего (Change Loop)

Используйте, когда нужно аккуратно поменять логику, не сломав остальное.

```text
/agentica.change --name Формат ошибок
Нужно перевести ошибки с string на JSON объект {code, msg}.
Важно: сохранить exit-codes для CLI, чтобы не сломать CI.
```
*Агент создаст `CH-XXXX`, проанализирует риски (Breaking Changes), предложит план миграции и только потом перейдет к коду.*

### 4. Архитектура и Реверс-инжиниринг

Если вы пришли в легаси-проект без доков или планируете сложную систему.

```text
/agentica.architect --name Анализ текущего монорепо
Восстанови карту модулей, найди циклические зависимости и
узкие места. Составь план рефакторинга.
```
*Агент создаст `AR-XXXX`, просканирует код и опишет систему "как есть" (As-Is).*

### 5. Рефакторинг (Anti-Spaghetti)

Когда код работает, но глазам больно.

```text
/agentica.refactor
В модуле отчетов функции по 300 строк.
Разбей на мелкие чистые функции, убери дубли.
Публичный API менять НЕЛЬЗЯ.
```
*Агент проведет рефакторинг, гарантируя сохранение внешнего контракта.*

### 6. Документация
```text
/agentica.readme --id FT-0012
Сделай короткую доку для разработчиков с примерами.
```