# Agentica

Spec Driven фреймворк для агентного кодинга. Вдохновлен SpecKit но ориентирован на Developer-first подход с параллельной поддержкой продуктового описания.

Основная цель данного проекта - сделать спеки легче и удобнее для того чтобы у разработчика было больше контроля над конечным результатом. В то время как SpecKit работает в пространстве "продукта", Agentica работает в пространстве "архитектора", предоставляя разработчику полный контроль над архитектурой проекта.


## Quick start

```bash
# Установка глобально для доступа из любой папки
npm install -g @jakerdy/agentica 

# Инициализация нового проекта
agentica init --name MyProject --stack typescript/cli 

# Открытие проекта в VSCode
cd MyProject
code .
```

## Мотивация

Agentica был создан в ходе поиска "идеального" инструмента для работы с агентными системами.

На момент начала 2026 года существует большое множество различных инструментов и подходов для того чтобы держать агента в "рамках" спецификации. Но большинство из них исходит из оптимистичного предположения о том что агентная система:
- достаточно умна чтобы писать качественный код
- может самостоятельно построить адекватную архитектуру
- может позволить пользователю быть менеджером/продактом который вообще не думает про качество и структуру кода

Однако это очевидным образом не находит подтверждения на практике, и агентный кодинг представляет собой одно из двух:
- Цикл бесконечной борьбы, в котором пользователь раз за разом затыкает дыры в реализации, получая в итоге качество кода "ниже среднего"
- Трудоёмкий процесс составления длинной детальной спецификации, на пару тысяч строк Markdown'а с постоянной вычиткой кучи текста, и невозможностью вернуться назад без изменения нескольких сотен строк MD за раз.

Но, при этом, агентные системы обладают одним замечательным свойством которое очень сложно игнорировать - они способны выдавать очень много кода за единицу времени. Но, для того чтобы это было полезно, и не только быстро, им нужна правильная спека, в которой будет очень конкретное и качественное описание того что и как нужно написать. 

Именно поэтому и был создан этот проект - создать конструктор спецификаций, в которой будут учтены как продуктовые, так и все важные технические детали, чтобы агент заполнил расстояние между строк.

## Описание подхода

Чтобы максимально продуктивно пользоваться фреймворком Agentica нужно для начала понять, с какими ограничениями мы работаем, и как их предполагается обходить.

Список всадников апокалипсиса агентного кодинга:
- **Контекст модели ограничен** - то, что знает и помнит модель при работе над кодом, это лишь малая часть всего проекта, и неявного контекста в котором он существует. Скажем 1/10 или даже 1/20 часть. И наша первостепенная задача сделать так, чтобы в контекст модели попало только то, что действительно важно для решения этой конкретной задачи, и полный набор ссылок на то, куда обязательно нужно в конце сходить и внедрить изменения.
- **Context Rot** - чем больше данных в контексте, тем глупее становится модель. Глупость конечно не очень великая - порядка 5-15% по сравнению с небольшим контекстом, но, тем не менее, чем уже скоуп спецификации, и "общих файлов" тем лучше статистически будет получаться результат.
- **Context Compaction** - при переполнении контекста, агент будет сжимать информацию выкидывая незначительные детали. Проблема тут в том, что он может выкинуть то, что было важно. Поэтому нам нужно либо помещаться в одну несжатую сессию, либо подготавливать контекст таким образом, чтобы после сжатия модель перечитывала важную информацию.
- **Говнокод** - модели обучались на корпусе открытого (и вероятно закрытого) кода с GitHub и прочих площадок. И беда тут в том, что в среднем люди пишут спагетти-код. Не из злого умысла, а скорее из-за обстоятельств. Молодой разработчик не опытен, и склонен к написанию переусложнённого спагетти-кода, который невозможно читать без боли. Так же, именно молодой разработчик скорее выложит свою поделку на GitHub с открытой лицензией, которая сделает этот код идеальным кандидатом для обучения. А дядьки которые уже 15+ лет в индустрии уже давным-давно работают в своих уютненьких банках/страховых/faang'e, и им уже давным-давно не нужно ничего контрибутить в OpenSource. Как итог, есть явный bias в сторону кода сомнительного качества, что мы и видим при запуске агентной системы без явного указания требуемой структуры кода. Агент скорее напишет 100 строк 10-этажных вложенных конструкций и тернарники четверной вложенности, нежели разделит это всё на небольшие плоские функции, но на 200 строк.

Из этих ограничений, можно сформулировать вполне понятный и необходимый список требований для фреймворка спецификаций, который будет срезать эти острые углы, и при этом быть эффективным для реализации больших проектов, которые будут жить долго, и будут оставаться при этом поддерживаемыми.

### Тех-Задание >> Продукт

Абсолютно все Spec-Driven фреймворки (*которые я видел и пробовал*) исходят из того, что продукт - первичен. Мол, если ты хочешь что-то сделать, сначала подумай о продуктовой ценности, пользовательских историях, и как это будет "ощущаться". Отсюда и термин - Vibe Coding, потому что мы опираемся на "ощущения от поведения реализации", а не на "техническую красоту" решения.

И то и другое - крайности.

Если думать только о "продукте", и забивать на "техничку", весь агентный кодинг превращается в коллекционирование тех-долга с самого начала проекта. Это норм для прототипов, но абсолютно неприемлемо для более-менее крупных проектов, которые должны жить больше пары месяцев.

Если думать только о "технической красоте", прожить оно сможет долго, только пользоваться этим никто не будет, так как скорее всего вы построите космолёт.

Нужно приземлиться где-то посередине. Нужно думать и о продукте (UX), и о технической стороне вопроса, потому как агент через 100k токенов всё забудет, а то что он написал станет вашей проблемой и ответственностью. Поэтому нужно сделать так, чтобы ответственность начиналась не после того как агент закончит, а до того как он начнёт. Чтобы именно вы придумали архитектуру и ключевые технические решения. Чтобы агенту осталось только "заполнить тело методов и функций". В этом случае вы с самого начала становитесь "владельцем" всех продуктовых и технических решений, что критически важно для реализации "длинных" проектов.

Именно поэтому, на этапе проектирования мы работаем сразу над "продуктовой" частью и "технической". И можем отдавать приоритет той или иной в зависимости от задачи. К примеру, работая над базовыми фундаментальными структурами в самом начале проекта, там "нет продукта", там есть техничка, в виде кешей, менеджеров, фабрик, и прочей инфры, с которой пользователь никогда напрямую не взаимодействует, но которая критически важна для будущего проекта. И тут важна именно инженерная составляющая, и в последнюю очередь продуктовая. В то же время, работая над новой панелькой в GUI, которая должна делать пользователю удобнее, продуктовая составляющая важна, а техничка как правило очень простая и не требует особого внимания.

### Узкий Scope

Контекст ограничен, ничего с этим не поделать. Но вот что мы туда подаём, можно ограничить.

Большинство проектов имеют модульную структуру, и редко бывают огромными монолитами на миллион строк. Как правило, это N-пакетов/библиотек/проектов которые зависят друг от друга. Между ними определены интерфейсы, и в целом над отдельными модулями можно работать параллельно. Примерно так же как это происходит в реальных командах, где разработчиков больше одного. Работа с агентами довольно сильно на это похожа, только для каждой задачи у тебя новый разработчик, и ты их можешь запускать параллельно (2-3) пока один работает, второго можно направить на путь истинный.

С инструментальной точки зрения это решается за счёт того, что мы кладём отдельную директорию .agentica не только в корень репозитория, но и в каждый отдельно взятый пакет/проект. Это позволяет:
- значительно сузить Scope попадающий в контекст, так как описываются только та архитектура/детали которые имеют непосредственное отношение к этому модулю
- значительно уточнить инструкции для каждого отдельно взятого модуля, не боясь раздувания контекста - 20 небольших файлов по 40 строк лучше чем 1 на 500.

### Anti-Spaghetti Метод

Для того чтобы агент не писал среднестатистический говнокод, предусмотрен анти-спагетти метод. Суть его заключается в том, что мы перечисляем всё то что нам не нравится в том как агент пишет код. Дополняем это "хорошими практиками", которые именно по вашему мнению должны быть реализованы. И редактируем этот набор до тех пор пока не станет совсем хорошо.

Далее этот список и используется в 2 местах: AGENTS.md в качестве фонового контекста, и в специальном промпте, который предназначен для рефакторинга.

Наличие этих правил на уровне AGENTS.md позволяет писать "дальше" "по правильному". А промпт для рефакторинга позволяет значительно улучшить код на уровне отдельно взятого файла, если до этого уже навайбкодили, или вы сами являетесь джуном, и хотите научиться писать код лучше и понятнее.


### Трекинг больных точек через семантическую валидацию

Спека, код, тесты, это хорошо. Но чтобы стало совсем хорошо, нужно ещё и Review.

Review'ить код написанный AI-кой, то ещё удовольствие. По крайней мере, на уровне первоначального этапа, когда тут и там торчат острые углы. Для этого нужен отдельный процесс валидации, которая позволит за несколько итераций сделать так, чтобы код максимально удовлетворял вашему внутреннему фен-шую, и был готов к применению в остальных местах проекта.

Сам процесс заключается в исчерпывающем чеклисте, того что мы можем написать на листочке в виде формальных требований. И, так как, над этим будет работать LLM, помимо инструментальных проверок: компилируется, собирается, форматируется, линтится. Можно ещё добавлять и семантические проверки - когда агент сам ходит по коду, и сверяет его с продуктовыми и техническими требованиями, описывая семантические несоответствия и рекомендации по их устранению.

## Команды

Agentica предоставляет следующие команды для управления жизненным циклом разработки:

### Формат ввода

Большинство команд принимает дополнительный текстовый ввод (`<user_input>`). Его можно передать:

- в той же строке после аргументов
- или с новой строки (удобнее для длинного описания)

```text
/agentica.<command> <options> [user_input]

# или
/agentica.<command> <options>
<user_input>
```

### Команды

Весь фреймворк построен на командах, которые очень специфическим образом синжинирены чтобы учитывать всё то, что было написано сверху, и после этого раздела.

**Аргументы команд**

Аргументы для команд опциональны, в большинстве случаев агент сам может понять где он находится:
- По файлам в корне репозитория
- По имени текущей ветки
- По пользовательскому инпуту

Но, если, в процессе работы над спекой, нужно внести какое-то изменение в соседний пакет/модуль, чтобы её было возможно реализовать, можно явно указать над чем сейчас будет происходить работа


#### Краткая сводка


| Команда               | Опциональные параметры                   | Назначение                                                                       |
| --------------------- | ---------------------------------------- | -------------------------------------------------------------------------------- |
| `/agentica.init`      | `--lang <language>` + `<user_input>`     | Инициализация нового проекта с базовой структурой и шаблонами                    |
| `/agentica.create`    | `--name <feature_name>` + `<user_input>` | Создание новой спецификации для реализации фичи или модуля                       |
| `/agentica.change`    | `--name <change_name>` + `<user_input>`  | Создание новой спецификации для внесения изменения в существующую реализацию     |
| `/agentica.architect` | `--name <arch_name>` + `<user_input>`    | Создание новой архитектурной спецификации для описания архитектуры               |
| `/agentica.iterate`   | `--id <spec_id>` + `<user_input>`        | Редактирование спецификации с помощью AI                                         |
| `/agentica.tasks`     | `--id <spec_id>` + `<user_input>`        | Генерация списка задач для конечной реализации спецификации                      |
| `/agentica.implement` | `--id <spec_id>` + `<user_input>`        | Запуск выполнения тасков, определённых в спецификации                            |
| `/agentica.validate`  | `--id <spec_id>` + `<user_input>`        | Семантическая и инструментальная валидация реализации спецификации               |
| `/agentica.readme`    | `--id <spec_id>` + `<user_input>`        | Генерация пользовательской документации для реализованной спецификации           |
| `/agentica.refactor`  | `<user_input>`                           | Рефакторинг существующей реализации с помощью AI без изменения её публичного API |


#### `/agentica.init`

Инициализация нового проекта с базовой структурой и подгонкой шаблонов

**Аргументы:**
- `--lang <programming-language-name>` - Язык программирования или стек на котором будет реализовываться проект
  - typescript
  - ts+react+tailwind+monogo+hono
  - ...
- `<user_input>` - Свободное описание пожеланий, на тему того что бы ты хотел видеть в инициализированном проекте, или что нужно сделать если проект уже был

**Пример:**

```text
/agentica.init --lang TypeScript
Сделай CLI для импорта данных из CSV.
Требуются команды: import, validate, report.
Нужны примеры использования и структура проекта.
```

#### `/agentica.create`

Создание новой feature-спеки.

**Аргументы:**
- `--name <feature_name>` - Человекочитаемое название фичи. Префикс и номер агент присвоит сам (`FT-XXXX`).
- `<user_input>` - Продуктовый и технический контекст по задаче.

**Пример:**

```text
/agentica.create --name Пакетная загрузка CSV
Нужна фича пакетной обработки CSV из директории.
Фильтрация по маске + отчёт по ошибкам в конце.
```

#### `/agentica.change`

Создание change-спеки для внесения изменений в существующую реализацию.

**Аргументы:**
- `--name <change_name>` - Человекочитаемое название изменения. Префикс и номер агент присвоит сам (`CH-XXXX`).
- `<user_input>` - Что меняем, зачем и какие есть ограничения (совместимость, риски, миграция).

**Пример:**

```text
/agentica.change --name Формат ошибок импорта
Перейти на формат code/message/details,
но сохранить текущие exit codes.
```

#### `/agentica.architect`

Создание архитектурной спеки для нового решения или reverse-engineering текущего.

**Аргументы:**
- `--name <arch_name>` - Человекочитаемое название архитектурного документа. Префикс и номер агент присвоит сам (`ARC-XXXX`).
- `<user_input>` - Цель, скоуп, ограничения и ожидаемые артефакты архитектуры.

**Пример:**

```text
/agentica.architect --name As-Is архитектура текущего монорепо
Нужно восстановить текущую карту модулей, интерфейсов и критичных зависимостей.
```

#### `/agentica.iterate`

Итеративная доработка уже созданной спецификации.

**Аргументы:**
- `--id <spec_id>` - ID спецификации (`FT-XXXX`, `CH-XXXX`, `ARC-XXXX`).
- `<user_input>` - Точные правки и уточнения к текущей версии спеки.

**Пример:**

```text
/agentica.iterate --id FT-0012
Добавь лимит размера файла до 100MB и retry для временных ошибок.
```

#### `/agentica.tasks`

Генерация задач для реализации спецификации.

**Аргументы:**
- `--id <spec_id>` - ID спецификации.
- `<user_input>` - Опциональные указания по приоритетам, этапам и зависимостям.

**Пример:**

```text
/agentica.tasks --id FT-0012
Разбей план на безопасные шаги, сначала без миграций.
```

#### `/agentica.implement`

Запуск реализации задач из спецификации.

**Аргументы:**
- `--id <spec_id>` - ID спецификации.
- `<user_input>` - Доп. ограничения на реализацию (например, не трогать внешний API).

**Пример:**

```text
/agentica.implement --id FT-0012
Реализуй только scope из задач и сохрани совместимость по публичным сигнатурам.
```

#### `/agentica.validate`

Проверка реализации: инструментальная + семантическая валидация по спеке.

**Аргументы:**
- `--id <spec_id>` - ID спецификации.
- `<user_input>` - Дополнительные критерии проверки, если нужно.

**Пример:**

```text
/agentica.validate --id CH-0007
Отдельно проверь слой совместимости и старые сценарии ошибок.
```

#### `/agentica.readme`

Генерация пользовательской документации для уже реализованной спецификации.

**Аргументы:**
- `--id <spec_id>` - ID спецификации.
- `<user_input>` - Для кого пишем, какой стиль и уровень детализации нужен.

**Пример:**

```text
/agentica.readme --id FT-0012
Сделай короткую доку для разработчиков с примерами CLI-команд.
```

#### `/agentica.refactor`

Рефакторинг существующего кода без изменения публичного API.

**Аргументы:**
- `<user_input>` - Где боль, что улучшить и какие инварианты нельзя ломать.

**Пример:**

```text
/agentica.refactor
В модуле отчётов большие функции и дубли.
Раздели на небольшие блоки без изменения внешних контрактов.
```





## Рабочие процессы

Agentica предусматривает несколько основных рабочих пайплайнов:

- Создание высокоуровневой архитектуры проекта
- Разработка новой фичи
- Внесение изменений в существующую кодовую базу
- Реверс-Инжиниринг архитектуры существующего проекта
- Рефакторинг говнокода

В каждом из этих пайплайнов применяется тот или иной набор промптов, с определёнными описаниями предстоящей задачи.

Давайте разберёмся по очереди с каждым таким процессом...

### Общие советы

- Новая фича - новый чат. Нам нужен максимально пустой и чистый контекст
- Вы должны знать что вы делаете. Агент за вас думать не будет, у него кончится контекст, и на это всё, теперь это ваша проблема. Поэтому внимательно читаем всё что он пишет и - максимально глубоко участвуем в том что он делает. Иначе будете генерить слоп который обрушится под своим весом через пару месяцев.
- Ваша задача - дать агенту максимально полный, но не переполненный контекст. Поэтому перед началом работы над новой "темкой", добавляйте все относящиеся к делу заметки, архитектурные документы, и ссылки на кодовую базу. Чтобы он мог в начале своего контекста всё это дело прочитать, спланировать работу, и записать это обратно в MD до того, как у него начнёт "гнить контекст", или ещё хуже - когда он закончится
- Если что-то не получилось и есть желание всё поменять в середине процесса. Это нормально. Удаляете спеку, создаёте новый чат, и пишите туда все свои предыдущие и новые соображения. Не нужно пытаться "спасти" эту спецификацию. Вы потратите в 3 раза больше времени, а результат всё-равно будет хуже. Выбрасывайте смелее, это сэкономит время.
- Научитесь писать на русском языке и максимально прямо и тупо излагать свои мысли. Если вы не можете чётко сформулировать свои мысли в виде текста, так чтобы их понял ваш товарищ по цеху, и думаете что "ну это же очевидно". Агент вас с высокой вероятностью не поймёт, мысли не прочитает, и выдаст "мусор". Поэтому спросите у LLM как писать хорошие, годные технические тексты, и попросите чтобы она вас по-коучила. Это сильно прокачает скил промптинга, и как следствие - контекст инжиниринга

### Создание высокоуровневой архитектуры проекта

Когда нам предстоит начать писать код для нового проекта, или при планировании новой мажорной версии, в идеале, нам нужно понимать следующие вещи:
- Кто и как им будет пользоваться
- На какие модули и компоненты будет декомпозирована система
- Какие технологии лучше применить для каждого компонента
- Какие зоны ответственности будут у этих компонентов
- Как будут выглядеть интерфейсы между модулями, и публичное API

Это всё не относящиеся напрямую к коду понятия, и не продуктовые. Это задачи на инжиниринг софтверной системы. Для этого не нужно писать исполняемый код, но без этих документов, при написании кода, будет возникать постоянная боль, в тех моментах когда нужно будет заниматься интеграцией компонентов.

Типичный луп работы с агентом:

```
---user
  /agentica.architect --name Модель данных основного документа

  Нужно спроектировать модель данных для документа, который будет редактироваться редактором.
  Посмотри #file:readme.md в нём описан планируемый функционал.
  Нужно понять, как это лучше сериализовать, какой контейнер использовать и т.д.

---agent
  Хорошо, понял тебя, сейчас прочитаю Readme и вернусь к тебе с вопросами 
  ...
  <Цикл интервью с пользователем на тему стека, подходов, и т.д.>
  ...
  Я создал новый документ `.agentica/architecture/ARC-0001 - Модель данных основного документа.md`.
  Открой его и прочти от начала до конца. Если будут какие-то правки, можешь обратиться ко мне через команду:
    `/agentica.iterate --id ARC-0001`

---user
  <Пользователь смотрит, читает док, у него появляются мысли, или он хочет задать вопрос>
  
  /agentica.iterate --id ARC-0001

  Я бы хотел посмотреть как бы это выглядело при использовании JSON и YAML форматов, создай пару примеров с типичным документом, я посмотрю как это будет выглядеть

---agent
  Да конечно, я создам 2 таких документа.

  <создаёт доки в .tmp/ARC-0001-examples>

  Можешь посмотреть их в:
  - `.tmp/ARC-0001-examples/sample.yaml` - Типичный документ в формате YAML
  - `.tmp/ARC-0001-examples/sample.json` - Типичный документ в формате JSON

---user
  ...


```

## Разработка новой фичи

Когда нужно добавить новую функциональность, пайплайн обычно выглядит так: 
- 1. описали идею 
- 2. уточнили спеку
- 3. разбили на задачи
- 4. реализовали
- 5. провалидировали
- 6. если всё готово: сгенерили юзерскую доку
- 8. если есть то добавить: goto -> шаг 2

Типичный луп:

```text
---user
  /agentica.create --name Пакетная загрузка CSV

  Нужна фича пакетной загрузки CSV файлов в CLI.
  Хочу чтобы можно было передавать папку, фильтровать по маске и получать отчёт по ошибкам в конце.

---agent
  Принял. Сейчас создам черновик спеки и задам уточняющие вопросы по UX и ограничениям.
  ...
  Я присвоил спецификации ID `FT-0012`.
  Я создал документы фичи:
  - `.agentica/features/FT-0012 - Пакетная загрузка CSV/product.md`
  - `.agentica/features/FT-0012 - Пакетная загрузка CSV/tech.md`
  - `.agentica/features/FT-0012 - Пакетная загрузка CSV/validation.md`

  Проверь их и дай правки через:
  `/agentica.iterate --id FT-0012`

---user
  /agentica.iterate --id FT-0012

  Добавь ограничение по размеру файла (до 100MB) и retry для временных ошибок чтения.

---agent
  Обновил спеку. Следующий шаг — разложить реализацию на таски:
  `/agentica.tasks --id FT-0012`

---user
  /agentica.tasks --id FT-0012

---agent
  Готово, я создал `tasks.md` с приоритетами и порядком выполнения.
  Если всё ок, запускаем реализацию:
  `/agentica.implement --id FT-0012`

---user
  /agentica.implement --id FT-0012

---agent
  Реализация завершена. Рекомендую сразу прогнать валидацию:
  `/agentica.validate --id FT-0012`

---user
  /agentica.validate --id FT-0012

---agent
  Нашёл 2 семантических замечания и 1 проблему в обработке ошибок.
  Внёс правки. Можно сгенерить пользовательскую документацию:
  `/agentica.readme --id FT-0012`
```

## Внесение изменений в существующую кодовую базу

Это режим, когда фича уже есть, но нужно что-то аккуратно поменять без ломаня текущего API и поведения в неожиданных местах.

Типичный луп:

```text
---user
  /agentica.change --name Формат ошибок импорта

  Нужно изменить формат ошибок в модуле импорта:
  сейчас строки, хочу структурированный объект с code/message/details.
  Важно не ломать публичный контракт CLI по exit codes.

---agent
  Отлично, это change-спека. Я зафиксирую:
  - текущее поведение
  - целевое поведение
  - план миграции
  - риски обратной совместимости

  Я присвоил спецификации ID `CH-0007`.
  Создал `.agentica/changes/CH-0007 - Формат ошибок импорта.md`.
  Для правок: `/agentica.iterate --id CH-0007`

---user
  /agentica.iterate --id CH-0007

  Добавь стратегию совместимости на 1 релиз: старый текст ошибки тоже должен остаться в поле legacyMessage.

---agent
  Принято, обновил. Дальше предлагаю:
  1) `/agentica.tasks --id CH-0007`
  2) `/agentica.implement --id CH-0007`
  3) `/agentica.validate --id CH-0007`

---user
  /agentica.validate --id CH-0007

---agent
  Проверил изменения по чеклисту: контракт сохранён, миграционный слой на месте,
  критичных расхождений со спекой нет.
```

## Реверс-Инжиниринг архитектуры существующего проекта

Когда проект уже живой, но документация умерла (или никогда не рождалась), мы сначала описываем как оно есть сейчас, и только потом решаем что с этим делать.

Типичный луп:

```text
---user
  /agentica.architect --name As-Is архитектура текущего монорепо

  Нужно восстановить архитектуру текущего монорепо:
  какие модули за что отвечают, какие зависимости критичны,
  где узкие места перед масштабированием команды.

---agent
  Ок, иду в режим reverse-engineering:
  прочитаю структуру проекта, ключевые entry points, package boundaries и публичные интерфейсы.
  ...
  Я присвоил спецификации ID `ARC-0011`.
  Создал документ:
  `.agentica/architecture/ARC-0011 - As-Is архитектура текущего монорепо.md`

  Там есть:
  - карта модулей
  - связи и потоки данных
  - зоны высокой сложности
  - список архитектурного долга

---user
  /agentica.iterate --id ARC-0011

  Добавь отдельный раздел: что можно выделить в независимые пакеты в ближайшие 2 итерации.

---agent
  Готово. Добавил секцию декомпозиции и поэтапный план без big-bang переписывания.
```

## Рефакторинг говнокода

Этот режим нужен когда код уже работает, но поддерживать его больно: вложенность, дубли, большие функции, неочевидные зависимости, магия в каждом втором методе.

Ключевая цель: улучшить читаемость и структуру без изменения публичного API.

Типичный луп:

```text
---user
  /agentica.refactor

  В модуле отчётов 3 огромные функции по 250+ строк,
  сложно тестировать и вносить изменения.
  Нужно разрезать на маленькие функции, убрать дубли, но не менять внешний контракт.

---agent
  Принял. Сначала сниму срез текущего поведения и инвариантов,
  затем сделаю план безопасного рефакторинга по шагам.
  ...
  Рефакторинг выполнен:
  - выделены чистые функции
  - устранены дублирующиеся ветки
  - упрощены условные конструкции
  - публичные сигнатуры не изменены

  Рекомендую сразу прогнать:
  `/agentica.validate --id <refactor-scope-id>`

---user
  /agentica.validate --id RF-0003

---agent
  Проверка пройдена: поведенческих расхождений по чеклисту не выявлено,
  код стал проще для поддержки и дальнейших изменений.
```