# Анти-спагетти метод: Единый Code Style Guide

## 1. Структура файла и Визуальное оформление
- **Принципы:** Код должен быть структурированным сверху вниз. Порядок секций фиксирован, это делает код предсказуемым.
- **Структура модуля (Strict):**
    1.  **Импорты**
    2.  **Константы** — магические числа/строки выносятся сюда.
    3.  **Интерфейсы/типы** — одноуровневые, без вложенности.
    4.  **Публичные функции/классы** — экспортируемое API.
    5.  **Приватные функции/классы** — внутренняя реализация.
    6.  **Утилитарные функции** — вспомогательные/экспорт в самом конце.
- **Четкое визуальное разделение:** Помечай группы широким однострочным разделителем-заголовком, чтобы визуально "разрезать" файл.
    - *Пример:*
        ```typescript
        //------------------- Constants ---------------------//
        //---------------------- Types ----------------------//
        //------------------- Public API --------------------//
        //---------------- Order Processor ------------------//
        //---------------------- Utils ----------------------//
        ```
- **Структура класса:** Придерживайся следующей очерёдности (state first):
    1.  **Приватные поля** (состояние).
    2.  **Конструктор**.
    3.  **Публичные свойства** (геттеры/сеттеры).
    4.  **Публичные методы**.
    5.  **Приватные методы**.
    6.  **Утилитарные методы** (статические).

## 2. Типизация и Данные (TypeScript)
- **Одноуровневые типы:** Создавай на каждый отдельный "объект" свой интерфейс/тип. Разбивай сложные вложенные типы на отдельные алиасы. Это улучшает читаемость и отладку.
    - *Плохо:* `function process(data: { items: { id: string }[] })`
    - *Хорошо:* `interface Item { id: string }; interface ProcessData { items: Item[] };`
- **Избегай дублирования DTO:** Не создавай 10 похожих интерфейсов для передачи одних и тех же данных. Если аргументов много и они повторяются — сгруппируй их в Класс или общий DTO.
- **Интерфейсы для DTO:** Для всех args-return структур использовать интерфейсы, даже если это всего 2-3 поля.
- **Прямые типы:** Используй типы напрямую (через импорты), избегай `typeof` или `ISomeType["field"]` в сигнатурах.

## 3. Плоскость (Flatness) и Поток управления
- **Принцип раннего возврата (Early Return):** Избегай конструкции `else`. Если в блоке `if` происходит `return`, `throw` или `break`, `else` не нужен. Это уменьшает визуальную вложенность.
- **Запрет на пирамиды:** Вложенные if-ы запрещены. Вычисли флаги по очереди и используй ранний возврат. Макс. 3-4 уровня вложенности — если больше, рефактори.
- **Распаковка цепочек методов:** Обязательное использование именованных переменных для промежуточных вычислений. Вместо цепочки в 10 этажей (`data.filter().map().reduce()...`) разбивай шаги на переменные:
    - *Пример:* `const activeItems = ...; const values = ...; const result = ...;`
- **Императивное >> Функционального:** Если можно написать простой цикл `for/of`, пиши его. Не городи сложные композиции из `reduce`, если это не улучшает читаемость.
- **Тернарные операторы:** Разрешены только если помещаются в одну строку и не содержат вложенности.

## 4. Простота (Simplicity) и Рефакторинг
- **Лимиты функции:** Макс. 30-40 строк кода. Функция должна помещаться на экран.
- **Лимит аргументов:** Не более 4-х аргументов. Если нужно больше — группируйте в объект (DTO) или превращайте функцию в класс.
- **Превращай мега-функции в классы:** Если функция имеет >100 строк, >5 аргументов или хранит сложное состояние в замыканиях (`let state = ...`), её нужно рефакторить в класс. Поля класса заменят замыкания, а методы — шаги алгоритма.
- **Единый уровень абстракции:** Внутри одной функции не должны перемешиваться высокоуровневая бизнес-логика и низкоуровневые манипуляции (парсинг JSON и расчет скидки рядом).

## 5. Чистота (Cleanliness) и Инкапсуляция
- **Defensive programming только на границах:** Проверки `null/undefined` нужны только на входе в публичный API (границы системы). Внутри приватных методов и между внутренними функциями — доверяй типизации TypeScript.
    - *Принцип:* "Не проверяй дважды". Если `handleUser` уже проверил `user`, то `processUser` не должен проверять его снова.
- **Инкапсуляция условий:** Запрет на "размазывание" логики. Вместо `if (order.total > 100 && order.user.isPremium)` используй метод модели `if (order.canApplyDiscount())`. Логика принадлежит объекту с данными.
- **Чистота булевых выражений:** Если условие `if` содержит более 2-х операторов, вынеси его в переменную (`const canAccess = ...`) или метод.
- **Запрет на мутации:** Функция не должна изменять входные параметры (immutability).
- **Запрет на Side Effects в геттерах:** Методы `get...` не должны менять состояние объекта или БД.

## 6. Общие запреты и стандарты
- **Магические значения:** Все числа, строки, таймауты и конфигурации — строго в константы с понятными именами (`const MAX_RETRY = 3`).
- **Никаких флагов в аргументах:** Если `boolean` аргумент меняет логику функции (ветвление внутри), раздели её на две разные функции.
- **Обработка ошибок:** Не должно быть методов, целиком завернутых в `try-catch`, кроме верхнего уровня публичного API.
- **Ограничение длины строки:** Максимум 100–120 символов (нет горизонтальному скроллу).
- **Мертвый код:** Закомментированный код удаляется безжалостно. Для истории есть Git.
- **Стрелочные функции:** Вложенные стрелки только для коротких лямбд. Если растет логика — выноси в именованную функцию.