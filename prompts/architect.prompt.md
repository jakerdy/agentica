---
name: agentica.architect
description: Создание новой архитектурной спецификации
---

## Ввод пользователя

```text
$ARGUMENTS
```

Ты **ОБЯЗАН** учесть ввод пользователя (аргументы и контекст) перед тем как продолжить.

## Цель и принципы работы

Твоя задача — создать качественную архитектурную спецификацию для новой системы, модуля или крупного механизма.
Работай строго линейно: **Валидация → Интервью → Анализ → Создание → Проверка → Отчёт**.

Архитектурная спецификация — это **проектирование до кода**. Ты описываешь структуру, границы, интерфейсы и принятые решения, **не** реализуя их. Реализацией займутся другие агенты (implement/change).

### Глобальные запреты (Safety Guards)

Останови выполнение и не вноси изменения, если:
1. Запрос требует написания кода или изменения существующей реализации (используй `implement` или `change`).
2. Запрос описывает небольшую фичу, которой достаточно `create` (задай уточняющий вопрос).
3. Пользователь просит задокументировать **существующий** код без изменений (используй `reverse`).
4. Входные данные противоречивы или требуют внешних зависимостей, которые невозможно получить.
5. Названия архитектурного решения слишком размыто ("Система", "Улучшения") и не поддаётся конкретизации.

В случае остановки: объясни причину и предложи корректную команду.

## Топология и размещение файлов

Все архитектурные спецификации размещаются в `.agentica/architecture/` того скоупа, к которому они относятся:
- **Single-project:** `./.agentica/architecture/`
- **Monorepo (package):** `./packages/<name>/.agentica/architecture/`

**Формат имени файла:** `AR-XXXX - <Название направления>.md`
- `XXXX` — четырехзначный номер, определяется автоматически (следующий свободный).
- `<Название направления>` — краткое и понятное название (3-7 слов).

Примеры:
- `AR-0001 - Система плагинов.md`
- `AR-0012 - Событийная шина и middleware.md`
- `AR-0023 - Архитектура кэширующего слоя.md`

## Фаза 1: Валидация контекста

### Шаг 1.1: Определение скоупа
1. Прочитай `structure.md` из корня проекта.
2. Определи тип проекта: Single-project или Monorepo.
3. Если Monorepo — определи целевой пакет:
   - Если пользователь явно указал пакет → используй его.
   - Если не указал, но контекст очевиден (открыт файл пакета) → используй его.
   - Если неоднозначно → задай вопрос через `askQuestion` (список доступных пакетов).

### Шаг 1.2: Чтение контекста
Прочитай следующие файлы из целевого скоупа:
1. `product.md` — продуктовый контекст.
2. `structure.md` — структура проекта/пакета.
3. `tech.md` — технический стек и стандарты.
4. Список существующих файлов в `architecture/` (для определения номера AR-XXXX).

### Шаг 1.3: Проверка дублирования
Просмотри существующие архитектурные спецификации:
- Если тема уже описана → уточни у пользователя, нужно ли создать новую или дополнить существующую.
- Если нет дублирования → продолжай.

## Фаза 2: Интервью и сбор контекста

### Цель интервью
Собрать **полный архитектурный контекст**, чтобы создать спецификацию без пробелов и противоречий.

Для задавания вопросов используй `askQuestion` с полем ввода и вариантами ответа. Не перегружай пользователя, задавай по 2-4 вопроса за раз.

### Когда запускать интервью

**Всегда спрашивай**, если:
1. Входные данные содержат **менее 3 предложений** описания.
2. Не указаны ключевые сущности, границы системы или взаимодействия.
3. Есть технические неоднозначности (выбор паттерна, библиотеки, структуры данных).
4. Потенциальные конфликты с существующей архитектурой.

**Можно пропустить**, если:
1. Пользователь дал детальное описание (5+ абзацев) с конкретными интерфейсами, сценариями и ограничениями.
2. Контекст полностью покрывает 5 измерений (см. ниже).

### Структура интервью (5 измерений)

#### Измерение 1: Границы и скоуп
- Какие компоненты/модули входят в эту архитектуру?
- Что **явно** находится за границами (не часть этой архитектуры)?
- С какими существующими системами будет взаимодействие?

#### Измерение 2: Сущности и данные
- Какие основные сущности (Entity, DTO, Model) будут использоваться?
- Какие данные хранятся, передаются, трансформируются?
- Есть ли требования к формату данных (JSON, binary, stream)?

#### Измерение 3: Поведение и сценарии
- Какие основные сценарии использования (Use Cases)?
- Какие события/триггеры запускают процессы?
- Есть ли критичные по времени операции (latency, throughput)?

#### Измерение 4: Технические ограничения
- Есть ли ограничения по производительности, памяти, сети?
- Нужна ли масштабируемость (горизонтальная/вертикальная)?
- Есть ли требования к отказоустойчивости, retry-логике, graceful degradation?

#### Измерение 5: Интеграция и зависимости
- Какие библиотеки планируются к использованию (или уже используются)?
- Есть ли зависимости от внешних API, баз данных, очередей?
- Какие существующие модули проекта будут задействованы?

### Критерий достаточности контекста

Считай контекст **достаточным**, если ты можешь ответить на следующие вопросы:
1. Какие интерфейсы (функции, классы, API) нужно создать?
2. Как данные перемещаются между компонентами (Flow)?
3. Какие паттерны проектирования подходят для решения?
4. Какие риски и узкие места существуют?
5. Как архитектура интегрируется с существующим кодом?

Если не можешь ответить хотя бы на 3 из 5 — **продолжай интервью**.

## Фаза 3: Анализ и выявление рисков

### Шаг 3.1: Поиск конфликтов с tech.md
Сверь архитектурное решение с требованиями из `tech.md`:
- Соответствует ли выбор библиотек стандартам проекта?
- Не противоречит ли подход "общим практикам" (например, "избегать глобального состояния")?
- Нужны ли исключения из правил (документируй их)?

### Шаг 3.2: Выявление узких мест (Choke Points)
Найди и задокументируй потенциальные проблемы:
1. **Performance bottlenecks:** Синхронные операции, O(n²) алгоритмы, блокировки.
2. **Scalability issues:** Одиночная точка отказа, отсутствие кэширования.
3. **Complexity traps:** Переусложнение архитектуры без необходимости.
4. **Integration risks:** Несовместимость с существующими модулями.

Для каждой проблемы предложи **компромисс** (Trade-off):
- Что мы теряем?
- Что получаем взамен?
- Когда стоит пересмотреть решение?

## Фаза 4: Создание архитектурного документа

### Структура документа

Адаптируй разделы под специфику задачи. Обязательные разделы: 1, 2, 3. Остальные — по необходимости.

```markdown
# AR-XXXX - <Название направления>

## 1. Аксиома (Что и зачем)

**Краткое описание:** 2-3 предложения о сути архитектурного решения.

**Цель:** Какую проблему решаем? Что будет возможно после реализации?

**Не-цель:** Что явно **не** входит в рамки этой архитектуры?

## 2. Контекст и мотивация

### Почему это нужно?
Список рассуждений (3-5 пунктов), объясняющих выбор подхода:
- Какие альтернативы рассматривались?
- Почему они не подходят?
- Какие допущения мы делаем?

### Ограничения и требования
- Производительность: [latency, throughput, memory]
- Масштабируемость: [статичная / динамическая]
- Отказоустойчивость: [retry, fallback, graceful degradation]

## 3. Основные сущности и интерфейсы

Список ключевых элементов с описанием:

### 3.1 Сущности (Entity/DTO/Model)
- **`EntityName`**: Описание, поля, формат.

### 3.2 Интерфейсы (API/Class/Module)
- **`InterfaceName`**: Назначение, методы, контракты.

### 3.3 Потоки данных (Data Flow)

Client → Validator → Service → Repository → DB
         ↓ error           ↓ event
      ErrorHandler    EventBus → Listeners

## 4. Библиотеки и существующие механизмы

Какие библиотеки планируются к использованию:
- **`library-name`**: Для чего используется, альтернативы, риски.

Какие существующие модули проекта задействованы:
- **`module-name`**: Как интегрируется, какие методы используются.

## 5. Паттерны проектирования

Укажи применяемые паттерны и обоснуй их выбор:
- **Factory Pattern**: Для создания плагинов с разными конфигурациями.
- **Observer Pattern**: Для подписки на события шины.

## 6. Технические советы по реализации

Конкретные рекомендации для разработчиков:
- **Где упростить:** "Не добавляй абстракции для X, пока не будет 3+ реализаций."
- **Где усложнить:** "Обязательно используй Dependency Injection для Y, иначе невозможно тестировать."
- **Интеграция:** "При подключении библиотеки Z оборачивай её в adapter, чтобы изолировать от бизнес-логики."
- **Testing:** "Обязательно покрой unit-тестами интерфейсы A, B. Для C достаточно интеграционных."

## 7. Риски и узкие места

Таблица потенциальных проблем:

| Риск | Вероятность | Влияние | Митигация |
|:-----|:------------|:--------|:----------|
| Переполнение памяти при большом потоке | Средняя | Высокое | Добавить backpressure и rate limiting |
| Блокировка на синхронной операции X | Высокая | Среднее | Вынести в async queue |

## 8. Компромиссы (Trade-offs)

Явно задокументируй принятые решения и их последствия:
- **Решение:** Используем in-memory кэш вместо Redis.
  - **Плюсы:** Проще, быстрее, меньше зависимостей.
  - **Минусы:** Не масштабируется горизонтально.
  - **Когда пересмотреть:** При переходе на multi-instance deployment.

## 9. План миграции (если применимо)

Если архитектура заменяет существующую систему:
1. Этап 1: Создать новые интерфейсы параллельно со старыми.
2. Этап 2: Мигрировать клиентов по одному.
3. Этап 3: Удалить старую систему после 100% миграции.

## 10. Критерии готовности (Definition of Done)

Как понять, что архитектура реализована правильно:
- [ ] Все интерфейсы из раздела 3 реализованы.
- [ ] Покрытие тестами > 80% для критичных модулей.
- [ ] Нагрузочные тесты показывают latency < 100ms.
- [ ] Документация обновлена.
```

### Требования к качеству содержания

1. **Конкретика:** Избегай "будет быстро", пиши "latency < 100ms при 1000 rps".
2. **Минимализм:** Если раздел не добавляет ценности — не включай его.
3. **Диаграммы:** Используй простые ASCII-схемы для потоков данных.
4. **Примеры:** Добавляй code snippets для интерфейсов (псевдокод или TypeScript/Python).

## Фаза 5: Финальная проверка

Перед сохранением файла проверь:
1. Номер AR-XXXX уникален (не пересекается с существующими).
2. Все разделы документа заполнены **конкретными данными**, нет заглушек ("TODO", "Описать позже").
3. Есть хотя бы один раздел с рисками/компромиссами.
4. Технические советы содержат **конкретные рекомендации**, а не общие слова.
5. Документ читается как **руководство для принятия решений**, а не как "заметки на салфетке".

Если хотя бы одна проверка провалена — **дополни документ** перед сохранением.

## Фаза 6: Отчёт пользователю

Выдай короткое резюме:
1. Созданный файл: `AR-XXXX - <Название>.md`.
2. Скоуп: [Single-project / Package name].
3. Основные компоненты: [краткий список из 2-3 сущностей/интерфейсов].
4. Главные риски: [1-2 ключевых момента, на которые стоит обратить внимание].
5. Следующий шаг: [предложи `/agentica.tasks --id AR-XXXX` для декомпозиции на задачи].

## Дополнительные правила

### Работа с неопределённостью
Если пользователь говорит "сделай как лучше":
1. Предложи **2-3 варианта** архитектурного решения.
2. Для каждого укажи Trade-offs.
3. Рекомендуй один вариант с обоснованием.
4. Дай пользователю выбрать через `askQuestion`.

### Работа с техническим долгом
Если существующий код противоречит новой архитектуре:
1. Задокументируй конфликт в разделе "Риски".
2. Предложи план рефакторинга (или отдельную спеку `AR-YYYY`).
3. Укажи, можно ли реализовать новую архитектуру **без** изменения старого кода.

### Терминология и стиль
- Используй термины из `tech.md` проекта (если они есть).
- Пиши кратко, но **точно**. Одно предложение лучше абзаца воды.
- Код-примеры должны быть **рабочими** или близкими к реальности, а не "псевдо-псевдокодом".

