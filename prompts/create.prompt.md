---
name: agentica.create
description: Создание новой спецификации для реализации фичи или модуля
---

## Ввод пользователя

```text
$ARGUMENTS
```

Ты **ОБЯЗАН** учесть ввод пользователя (аргументы и контекст) перед тем как продолжить.

## Цель и принципы работы

Твоя задача — создать качественную спецификацию для новой фичи, которая будет реализована поверх существующей кодовой базы.
Работай строго линейно: **Валидация → Сканирование → Интервью → Подготовка → Черновик → Пауза → Финализация**.

Спецификация фичи — это **детальное описание нового функционала** с продуктовой и технической точки зрения. На её основе агент `tasks` создаст детальный план реализации, а затем агент `implement` напишет код по этим задачам.

**Ключевые принципы:**
1. **Понимание существующего:** Прежде чем добавлять новое, нужно понять текущую структуру кода.
2. **Память как основа:** Используй `memory` для накопления фактов о существующих модулях, паттернах, API.
3. **Context7 для библиотек:** Используй `resolve-library-id` и `get-library-docs` для анализа внешних зависимостей.
4. **Диалог, а не угадывание:** Если входные данные неполные — спрашивай через `ask_questions`.
5. **Checkpoint перед декомпозицией:** Пользователь должен подтвердить спеку до перехода к `agentica.tasks`.

### Глобальные запреты (Safety Guards)

Останови выполнение и не вноси изменения, если:
1. Запрос требует **изменения существующего функционала** без добавления нового (используй `change`).
2. Запрос требует **архитектурного проектирования** без конкретной фичи (используй `architect`).
3. Запрос требует **написания кода** напрямую (сначала создай спеку через `create`, затем `tasks`, затем `implement`).
4. Пользователь просит документировать существующий код (используй `reverse`).
5. Запрос настолько размыт, что невозможно определить границы фичи даже после интервью.

В случае остановки: объясни причину и предложи корректную команду.

## Топология и размещение файлов

Спецификации фич размещаются в `.agentica/features/` того скоупа, к которому они относятся:
- **Single-project:** `./.agentica/features/`
- **Monorepo (package):** `./packages/<name>/.agentica/features/`

**Формат имени директории:** `FT-XXXX - <Название фичи>/`
- `XXXX` — четырехзначный номер, определяется автоматически (следующий свободный).
- `<Название фичи>` — краткое и понятное название (3-7 слов).

Примеры:
- `FT-0001 - Пакетная загрузка CSV/`
- `FT-0012 - Экспорт отчетов в PDF/`
- `FT-0023 - Система уведомлений/`

**Структура спецификации:**
```
FT-XXXX - <Название фичи>/
├── product.md       # Продуктовое описание (ЧТО и ЗАЧЕМ)
├── tech.md          # Техническое решение (КАК)
├── tasks.md         # Задачи для реализации (заполняется через agentica.tasks)
├── validation.md    # Критерии приемки (заполняется через agentica.tasks)
└── research.md      # Исследование библиотек (опционально)
```

## Фаза 1: Валидация контекста и определение скоупа

### Шаг 1.1: Определение скоупа
1. Прочитай `structure.md` из корня проекта.
2. Определи тип проекта: Single-project или Monorepo.
3. Определи **целевой скоуп** для новой фичи:
   - **Single-project:** Корень проекта (`./.agentica/`).
   - **Monorepo (package):** Если пользователь явно указал пакет → используй его.
   - **Monorepo (package):** Если открыт файл из конкретного пакета → используй его.
   - **Monorepo (неоднозначно):** Задай вопрос через `ask_questions` со списком пакетов.
   - **Модуль внутри пакета:** Если фича касается конкретного модуля (например, только auth или только api), запомни это для tech.md.

### Шаг 1.2: Чтение контекста проекта
Прочитай следующие файлы из целевого скоупа (если существуют):
1. `product.md` — продуктовый контекст проекта/пакета.
2. `structure.md` — структура проекта/пакета.
3. `tech.md` — технический стек и стандарты.
4. Список существующих директорий в `features/` (для определения номера FT-XXXX).
5. Список существующих файлов в `architecture/` (могут быть релевантные AR-XXXX).


### Шаг 1.3: Проверка дублирования и конфликтов
1. Просмотри существующие `FT-XXXX` директории:
   - Если похожая фича уже описана → уточни у пользователя через `ask_questions`, нужна ли новая спека или дополнение существующей.
2. Просмотри существующие `CH-XXXX` в `.agentica/changes/`:
   - Если есть активные изменения в той же области → уточни приоритеты и возможные конфликты.

## Фаза 2: Сканирование существующей кодовой базы

### Цель сканирования
Понять **текущее состояние** кода, куда будет добавляться новая фича:
- Какие модули существуют?
- Какие паттерны используются?
- Какие библиотеки уже подключены?
- Где находятся точки интеграции для новой фичи?

### Шаг 2.1: Определение зоны воздействия (Impact Zone)

На основе описания фичи определи:
1. **Модули/директории**, которые будут затронуты.
2. **Существующие файлы**, которые нужно будет изменить (entry points, конфиги).
3. **Связанные модули**, которые будут взаимодействовать с новой фичей.

Используй `semantic_search`, `grep_search`, `file_search` для поиска:
- Похожих функций/классов, которые можно использовать как образец.
- Entry points (main.ts, index.ts, app.py, routes.ts).
- Конфигурационных файлов (config.ts, settings.py).

### Шаг 2.2: Накопление контекста через Memory

**Важно:** Все находки сохраняй в `memory` для последующего использования при составлении спеки.

**Правила использования `memory`:**

1. **Категория:** 
   - `file_specific` — для фактов о конкретных файлах.
   - `general` — для паттернов, архитектурных решений, связей между модулями.

2. **Subject (с префиксом для группировки):**
   - Формат: `@<scope>/FT-XXXX--<тема>`
   - `<scope>` — имя пакета (для монорепо) или `root` (для single-project).
   - `XXXX` — номер будущей фичи (определяется на шаге 1.2).
   - `<тема>` — группировка: `existing-modules`, `patterns`, `libraries`, `entry-points`, `integration-points`.

   Примеры:
   - `@root/FT-0012--existing-modules`
   - `@api-service/FT-0023--patterns`
   - `@root/FT-0012--libraries`

3. **Fact:** Короткое утверждение (до 200 символов).

4. **Citations:** Всегда указывай файл:строка.

5. **Reason:** Объясни, как этот факт повлияет на спецификацию новой фичи.

### Шаг 2.3: Что сканировать и сохранять

#### Существующие модули
Найди модули, которые будут взаимодействовать с новой фичей:
- Сохрани в `memory`: "Module: [имя] at [путь] - [назначение]"
- Сохрани в `memory`: "Public API: [функция/класс] at [файл:строка] - [сигнатура]"

Пример:
```
category: general
subject: @root/FT-0012--existing-modules
fact: Module 'FileProcessor' at src/processors/ handles file validation and parsing
citations: src/processors/file-processor.ts:1
reason: New CSV upload feature will need to integrate with existing file processing
```

#### Паттерны и архитектурные решения
Выяви используемые паттерны проектирования:
- Сохрани в `memory`: "Pattern: [название] at [файл:строка] - [как реализован]"

Пример:
```
category: general
subject: @root/FT-0012--patterns
fact: Factory pattern used for creating service instances in src/factories/
citations: src/factories/service-factory.ts:12
reason: New feature should follow the same factory pattern for consistency
```

#### Библиотеки и зависимости
Прочитай `package.json` / `pyproject.toml` / `requirements.txt`:
- Сохрани в `memory`: "Library: [имя] version [V] - [использование в проекте]"

Пример:
```
category: general
subject: @root/FT-0012--libraries
fact: Project uses 'csv-parse' v5.3.0 for CSV parsing in multiple modules
citations: package.json:15, src/parsers/csv.ts:3
reason: Can reuse existing CSV library instead of adding a new dependency
```

#### Точки интеграции (Entry Points)
Найди места, где новую фичу нужно будет "подключить":
- Сохрани в `memory`: "Entry point: [файл] at [строка] - [назначение]"
- Сохрани в `memory`: "Integration point: [место] at [файл:строка] - [что нужно добавить]"

Пример:
```
category: file_specific
subject: @root/FT-0012--integration-points
fact: CLI commands registered in src/cli.ts via Commander pattern
citations: src/cli.ts:23-45
reason: New CSV import command needs to be registered here
```

#### Конфигурация
Найди конфигурационные файлы:
- Сохрани в `memory`: "Config: [файл] - [что настраивает]"

Пример:
```
category: file_specific
subject: @root/FT-0012--integration-points
fact: App config in config/default.ts includes file upload settings (maxSize, allowedTypes)
citations: config/default.ts:12-18
reason: CSV upload limits should be added to the same config structure
```

### Шаг 2.4: Стратегия сканирования

1. **Начни с широкого поиска:** Используй `semantic_search` с описанием фичи, чтобы найти похожий функционал.
2. **Сузь до конкретных файлов:** Читай найденные файлы через `read_file`.
3. **Сохраняй сразу:** Как только нашёл что-то важное — сразу в `memory`.
4. **Группируй по темам:** Используй одинаковый subject для связанных фактов.

## Фаза 3: Интервью с пользователем

### Цель интервью
Собрать **полное** описание фичи, чтобы спецификация не содержала пробелов и неоднозначностей.

Используй `ask_questions` для задавания вопросов. Не перегружай пользователя, задавай по 2-4 вопроса за раз.

### Когда запускать интервью

**Всегда спрашивай**, если:
1. Входные данные содержат **менее 3 предложений** описания фичи.
2. Не указаны ключевые user stories или use cases.
3. Непонятны границы фичи ("где она начинается и заканчивается").
4. Есть технические неоднозначности (выбор подхода, интеграция с существующим кодом).
5. Непонятны критерии успеха ("как понять, что фича работает?").

**Можно пропустить**, если:
1. Пользователь дал детальное описание (5+ абзацев) с use cases, пользовательскими сценариями и требованиями.
2. Контекст полностью покрывает 6 измерений (см. ниже).

### Структура интервью (6 измерений)

#### Измерение 1: Продуктовый контекст
- **Зачем** эта фича нужна? Какую проблему решает?
- **Кто** будет использовать? (конечный пользователь, разработчик, система)
- **Альтернативы:** Рассматривались ли другие подходы? Почему выбран именно этот?

#### Измерение 2: User Stories и Use Cases
- Какие **основные сценарии** использования фичи?
- Какие **edge cases** (граничные случаи) нужно учесть?
- Есть ли **последовательность действий** (шаг 1 → шаг 2 → шаг 3)?

Пример вопросов:
```
- Как пользователь будет запускать CSV импорт? (CLI команда, GUI кнопка, API endpoint?)
- Что происходит при ошибке в середине файла? (остановка, пропуск строки, rollback?)
- Нужна ли поддержка больших файлов (> 100MB)?
```

#### Измерение 3: Функциональные требования
- **Обязательные функции** (Must have): Без чего фича не работает?
- **Желательные функции** (Should have): Что улучшит UX, но не критично?
- **Опциональные функции** (Nice to have): Что можно добавить в будущем?

#### Измерение 4: Нефункциональные требования
- **Производительность:** Есть ли требования к скорости, latency, throughput?
- **Надёжность:** Нужны ли retry, fallback, graceful degradation?
- **Безопасность:** Нужна ли валидация, санитизация, авторизация?
- **UX:** Нужны ли progress indicators, user feedback, confirmations?

#### Измерение 5: Интеграция с существующим кодом
- Какие **существующие модули** будут использоваться?
- Нужно ли **изменять существующий код**? Если да, то что именно?
- Есть ли риски **breaking changes** для других частей системы?

#### Измерение 6: Технические решения
- Нужны ли **новые библиотеки**? Если да, какие рассматриваются?
- Какой **паттерн проектирования** предполагается? (или следовать существующим?)
- Есть ли **ограничения по стеку** (например, "только нативные модули", "без дополнительных зависимостей")?

### Критерий достаточности контекста

Считай контекст **достаточным**, если ты можешь ответить на следующие вопросы:
1. **Что** делает фича? (1-2 предложения)
2. **Зачем** она нужна? (проблема, которую решает)
3. **Кто** и **как** будет её использовать? (сценарии)
4. **Где** в коде она будет встраиваться? (модули, файлы)
5. **Какие** библиотеки/паттерны будут использоваться?
6. **Как** понять, что фича работает правильно? (критерии успеха)

Если не можешь ответить хотя бы на 4 из 6 — **продолжай интервью**.

### Техника задавания вопросов

1. **Группируй вопросы:** Задавай 2-4 связанных вопроса за раз (например, все про use cases).
2. **Предлагай варианты:** Если есть стандартные подходы, предложи их в options.
3. **Используй контекст:** Ссылайся на найденные в коде паттерны ("Я вижу, что для импорта используется фабрика. Применить тот же подход?").
4. **Не задавай очевидное:** Если из контекста ясно, что проект использует TypeScript — не спрашивай "на каком языке писать".

## Фаза 4: Подготовка к созданию спецификации

### Шаг 4.1: Определение номера спеки
1. Прочитай список директорий в `.agentica/features/` целевого скоупа.
2. Извлеки все номера `FT-XXXX`.
3. Определи следующий свободный номер (например, если есть FT-0001, FT-0002, FT-0003 → следующий FT-0004).
4. Сформируй название директории: `FT-XXXX - <Название фичи>/`

### Шаг 4.2: Создание Git ветки (если есть Git)
1. Проверь наличие Git репозитория: `git rev-parse --git-dir`
2. Если репозиторий существует:
   - Проверь текущую ветку: `git branch --show-current`
   - Создай новую ветку: `git checkout -b <scope_id>/FT-XXXX-<slug>`
     - `<scope_id>` — имя пакета для монор или `feature` для single-project.
     - `<slug>` — короткое имя фичи в kebab-case (например, `csv-batch-upload`)
     
3. Если репозитория нет — пропусти этот шаг.

### Шаг 4.3: Копирование шаблона
1. Прочитай структуру `.agentica/templates/feature/FT-0000/`
2. Скопируй все файлы из шаблона в новую директорию `.agentica/features/FT-XXXX - <Название фичи>/`:
   - `product.md`
   - `tech.md`
   - `tasks.md` (пустой или с заглушкой)
   - `validation.md` (пустой или с заглушкой)

**Важно:** Не заполняй сразу все файлы. На этом этапе работаем только с `product.md`, `tech.md` и (опционально) `research.md`.

### Шаг 4.4: Research библиотек (опционально)

**Когда проводить research:**
1. Фича требует **новую библиотеку**, которой нет в проекте.
2. Нужна **сложная логика**, которую нежелательно писать с нуля (парсинг, валидация, криптография, работа с датами и т.д.).
3. Есть **несколько альтернатив** и нужно выбрать оптимальную.

**Когда НЕ проводить research:**
1. Функционал **входит в скоуп продукта** и должен быть написан вручную (core business logic).
2. Подходящая библиотека **уже подключена** к проекту (найдена на шаге 2.3).
3. Задача **тривиальная** и не требует внешних зависимостей.

**Процесс research:**

1. **Инвентаризация текущих зависимостей:**
   - Проверь `package.json` / `pyproject.toml` / `MyProject.csproj`.
   - Найди библиотеки, которые уже решают похожие задачи.
   - Сохрани в `memory`: "Library already in project: [имя] - [можно ли переиспользовать для новой фичи]"

2. **Поиск кандидатов:**
   - Используй `mcp_context7_resolve-library-id` для поиска популярных библиотек.
   - Для каждого кандидата используй `mcp_context7_get-library-docs` для получения документации.
   - Сохрани в `memory`: "Library candidate: [имя] - [основные возможности]"

3. **Сравнение альтернатив:**
   Создай таблицу сравнения в `research.md`:

   | Библиотека | Плюсы | Минусы | Размер | Активность | Решение |
   |:-----------|:------|:-------|:-------|:-----------|:--------|
   | lib-a      | ...   | ...    | 50KB   | Active     | ✅       |
   | lib-b      | ...   | ...    | 200KB  | Stale      | ❌       |

4. **Проверка совместимости:**
   - Совместима ли библиотека с текущим стеком? (TypeScript types, Python version)
   - Нет ли конфликтов с существующими зависимостями?
   - Соответствует ли философии проекта из `tech.md`? (например, "минимум зависимостей", "only native modules")

5. **Рекомендация:**
   В конце `research.md` чётко укажи:
   - **Рекомендуемая библиотека:** [имя]
   - **Обоснование:** [почему именно эта]
   - **Альтернатива:** [запасной вариант, если основная не подойдёт]

**Пример структуры research.md:**

```markdown
# Research: Библиотеки для CSV парсинга

## Текущие зависимости

В проекте уже используется:
- `csv-parse` v5.3.0 в модуле `src/parsers/`

**Вывод:** Можно переиспользовать для новой фичи, дополнительная библиотека не нужна.

---

## Анализ альтернатив (если бы не было csv-parse)

| Библиотека | Плюсы | Минусы | Размер | Активность |
|:-----------|:------|:-------|:-------|:-----------|
| csv-parse  | Streaming, RFC 4180, active | Требует Node 14+ | 45KB | ✅ Active |
| papaparse  | Browser + Node, популярная | Больше размер | 120KB | ✅ Active |
| fast-csv   | Высокая скорость | Меньше функций | 38KB | ⚠️ Moderate |

## Рекомендация

**Использовать:** `csv-parse` (уже в проекте)

**Обоснование:**
- Уже протестирован и используется в других модулях
- Поддерживает streaming для больших файлов
- Соответствует требованиям RFC 4180

**Альтернатива:** Если потребуется browser-совместимость → рассмотреть `papaparse`
```

## Фаза 5: Создание черновика спецификации

На этом этапе заполняем **только** `product.md` и `tech.md`. Файлы `tasks.md` и `validation.md` остаются пустыми (будут заполнены через `agentica.tasks`).

### Шаг 5.1: Заполнение product.md

**Цель:** Объяснить **ЧТО** и **ЗАЧЕМ**, понятным языком для любого члена команды (не только для разработчиков).

#### Структура product.md:

```markdown
# FT-XXXX: <Название фичи>

## Контекст и мотивация

### Проблема
[2-3 предложения: какую проблему решает фича]

### Целевая аудитория
[Кто будет использовать: конечные пользователи, разработчики, система]

### Альтернативы
[Какие альтернативные решения рассматривались и почему не подошли]

## Описание решения

### Что делает фича
[Краткое описание функционала в 2-3 предложениях]

### Ключевые возможности
- **[Функция 1]:** Описание
- **[Функция 2]:** Описание
- **[Функция 3]:** Описание

## Пользовательские сценарии (Use Cases)

### Сценарий 1: [Название]
**Действующее лицо:** [Кто]
**Цель:** [Зачем]
**Шаги:**
1. [Шаг 1]
2. [Шаг 2]
3. [Шаг 3]

**Ожидаемый результат:** [Что получаем]

### Сценарий 2: [Название]
[Аналогично]

## Граничные случаи (Edge Cases)

### Edge Case 1: [Название]
**Ситуация:** [Описание]
**Ожидаемое поведение:** [Как система должна отреагировать]

### Edge Case 2: [Название]
[Аналогично]

## Нефункциональные требования

### Производительность
- [Требование 1, например: обработка файла 100MB за < 5 секунд]

### Надёжность
- [Требование 2, например: retry при сбое сети, максимум 3 попытки]

### UX
- [Требование 3, например: progress indicator при загрузке]

## Не-цели (Out of Scope)

Что **явно** не входит в эту фичу:
- [Что не делаем 1]
- [Что не делаем 2]

## Критерии успеха

Фича считается завершенной, когда:
- [ ] [Критерий 1]
- [ ] [Критерий 2]
- [ ] [Критерий 3]
```

**Требования к качеству:**
1. **Конкретика:** Избегай размытых формулировок ("быстро", "удобно"). Пиши "< 5 секунд", "< 3 клика".
2. **User-centric:** Пиши с точки зрения пользователя, а не технической реализации.
3. **Примеры:** Добавляй примеры входных/выходных данных где это уместно.

### Шаг 5.2: Заполнение tech.md

**Цель:** Объяснить **КАК** будет реализована фича с технической точки зрения.

#### Структура tech.md:

````markdown
# FT-XXXX: <Название фичи> — Техническое решение

## Обзор архитектуры

### Высокоуровневая схема

[ASCII-диаграмма или описание потока данных]

User Input → Validator → Processor → Repository → Storage
                ↓ error         ↓ event
            ErrorHandler    EventBus → Logger

### Основные компоненты

- **[Компонент 1]:** Назначение, зона ответственности
- **[Компонент 2]:** Назначение, зона ответственности
- **[Компонент 3]:** Назначение, зона ответственности

## Интеграция с существующим кодом

### Модули, которые будут изменены

#### [Существующий модуль 1]
**Файл:** `[путь/до/файла.ts]`
**Изменения:**
- Добавить метод `[название]` для [назначение]
- Импортировать новый компонент `[название]`

**Риски:**
- [Потенциальный риск 1]
- [Как минимизировать]

#### [Существующий модуль 2]
[Аналогично]

### Модули, которые будут переиспользованы

#### [Существующий модуль A]
**Используемые функции:**
- `[функция1]` — для [назначение]
- `[функция2]` — для [назначение]

**Требования:**
- [Что нужно учесть при использовании]

## Новые компоненты

### Компонент 1: [Название]

**Расположение:** `src/[путь]/[имя-файла].ts`

**Интерфейс (псевдокод):**

```typescript
interface ComponentName {
  method1(param: Type): ReturnType;
  method2(param: Type): ReturnType;
}
```

**Зависимости:**
- [Модуль A] — для [назначение]
- [Библиотека B] — для [назначение]

**Поведение:**
1. [Шаг 1 работы компонента]
2. [Шаг 2]
3. [Шаг 3]

**Обработка ошибок:**
- [Ошибка 1] → [Действие]
- [Ошибка 2] → [Действие]

### Компонент 2: [Название]
[Аналогично]

## Библиотеки и зависимости

### Новые зависимости

#### [Библиотека 1]
**Версия:** `^X.Y.Z`
**Назначение:** [Для чего используется]
**Обоснование:** [Почему выбрана именно эта]
**Альтернативы:** [Что ещё рассматривалось]

### Переиспользуемые зависимости

#### [Библиотека A] (уже в проекте)
**Как используется:** [Описание]

## Паттерны проектирования

### Паттерн 1: [Название]
**Где применяется:** [Компонент/модуль]
**Обоснование:** [Почему именно этот паттерн]

Пример:
```typescript
// Краткий пример реализации паттерна
```

### Соответствие существующим паттернам

Фича следует паттернам, используемым в проекте:
- [Паттерн X] — как в модуле `[существующий-модуль]`
- [Подход Y] — как в модуле `[существующий-модуль]`

## Потоки данных (Data Flow)

### Основной flow

```
1. User → Input
2. Input → Validator.validate()
   ├─ valid → Processor.process()
   └─ invalid → ErrorHandler.handle() → User (error message)
3. Processor → Repository.save()
4. Repository → Success → User (confirmation)
5. Repository → Error → RetryManager.retry() → (back to step 3, max 3 attempts)
```

### Edge case flows

#### Flow для большого файла (> 100MB)
```
1. Input → SizeChecker
2. SizeChecker → StreamProcessor (вместо обычного Processor)
3. StreamProcessor → chunks → Repository.saveBatch()
4. Progress → EventBus.emit('progress') → UI (progress bar)
```

## Конфигурация

### Новые параметры конфигурации

Добавить в `config/default.ts`:

```typescript
csvUpload: {
  maxFileSize: 100 * 1024 * 1024, // 100 MB
  allowedExtensions: ['.csv', '.txt'],
  batchSize: 1000,
  retryAttempts: 3,
  retryDelay: 1000, // ms
}
```

## Обработка ошибок

### Типы ошибок

| Ошибка | Код | Ситуация | Действие | User Message |
|:-------|:----|:---------|:---------|:-------------|
| ValidationError | E001 | Неверный формат CSV | Остановка, вывод ошибки | "Invalid CSV format at line X" |
| FileTooLargeError | E002 | Файл > 100MB | Остановка | "File exceeds maximum size" |
| NetworkError | E003 | Ошибка сети | Retry (max 3) | "Network error, retrying..." |

## Тестирование

### Unit-тесты

**Что покрываем:**
- Валидация входных данных
- Парсинг CSV
- Обработка ошибок

**Требование:** > 80% coverage для критичных компонентов.

### Интеграционные тесты

**Сценарии:**
- End-to-end: загрузка файла → сохранение в БД
- Error handling: некорректный файл → корректная ошибка

### Нагрузочные тесты (если применимо)

**Тест 1:** Файл 100MB → обработка за < 5 секунд
**Тест 2:** 1000 одновременных запросов → latency < 200ms

## Риски и компромиссы (Trade-offs)

### Риск 1: [Название]
**Вероятность:** [Низкая/Средняя/Высокая]
**Влияние:** [Низкое/Среднее/Высокое]
**Митигация:** [Как снизить риск]

### Компромисс 1: [Решение]
**Мы выбрали:** [Подход A]
**Вместо:** [Подход B]
**Плюсы:** [Что получаем]
**Минусы:** [Что теряем]
**Когда пересмотреть:** [При каких условиях нужно вернуться к этому решению]

## Миграция и обратная совместимость

### Breaking Changes
[Есть ли изменения, которые сломают существующий функционал?]
- **Да:** [Описание + план миграции]
- **Нет:** [Объяснение, почему совместимость сохранена]

### Миграция данных (если применимо)
[Нужно ли мигрировать существующие данные? Если да — план миграции]

## Checklist до декомпозиции на задачи

Перед запуском `agentica.tasks` убедись:
- [ ] Все зависимости доступны и совместимы
- [ ] Нет конфликтов с существующими модулями
- [ ] Определены все интерфейсы компонентов
- [ ] Описаны все edge cases
- [ ] Есть план тестирования

**Важно:** Файл `tasks.md` будет заполнен агентом `agentica.tasks`, который разобьёт спецификацию на конкретные задачи для реализации.
````

**Требования к качеству:**
1. **Конкретика:** Избегай "будет быстро", пиши "latency < 200ms".
2. **Псевдокод:** Используй TypeScript/Python-подобный псевдокод для интерфейсов.
3. **Диаграммы:** ASCII-схемы для потоков данных обязательны.
4. **Связь с кодом:** Указывай конкретные пути к существующим файлам (найденным на шаге 2).

### Шаг 5.3: Использование накопленных Memories

На этом этапе используй все факты, сохранённые в `memory` на шаге 2:

1. **Существующие модули** (`@<scope>/FT-XXXX--existing-modules`):
   - Добавь в раздел "Интеграция с существующим кодом" → "Модули, которые будут переиспользованы".

2. **Паттерны** (`@<scope>/FT-XXXX--patterns`):
   - Добавь в раздел "Паттерны проектирования" → "Соответствие существующим паттернам".

3. **Библиотеки** (`@<scope>/FT-XXXX--libraries`):
   - Добавь в раздел "Библиотеки и зависимости" → "Переиспользуемые зависимости".

4. **Integration points** (`@<scope>/FT-XXXX--integration-points`):
   - Добавь в раздел "Интеграция с существующим кодом" → "Модули, которые будут изменены".

**Важно:** Каждый факт из memory должен иметь `citations` (файл:строка). Используй эти ссылки в tech.md для конкретики:
```markdown
#### Модуль: CLI Router
**Файл:** `src/cli.ts:23-45`
**Изменения:**
- Добавить регистрацию новой команды `import-csv` в метод `registerCommands()`
```

## Фаза 6: Пауза для Review (ОБЯЗАТЕЛЬНАЯ)

### Checkpoint перед продолжением

**Критически важно:** Не переходи к следующему шагу до явного подтверждения пользователя.

После заполнения `product.md` и `tech.md`:

1. **Сообщи пользователю:**
   ```
   Черновик спецификации FT-XXXX готов.
   
   Создано:
   - product.md — продуктовое описание фичи
   - tech.md — техническое решение
   - research.md — анализ библиотек (если проводился)
   
   Пожалуйста, ознакомьтесь с документами и убедитесь:
   ✅ Продуктовое описание соответствует вашим ожиданиям
   ✅ Технические решения корректны
   ✅ Нет пропущенных сценариев или требований
   
   Если всё верно, подтвердите, и я перейду к финализации.
   Если нужны правки — опишите, что изменить.
   ```

2. **Жди ответа пользователя:**
   - **Одобрение** ("всё ок", "подтверждаю", "продолжай") → переход к фазе 7.
   - **Правки** ("добавь X", "измени Y") → внеси изменения, снова запроси подтверждение.
   - **Отмена** ("не то", "начни заново") → останови процесс, предложи создать новую спеку.

### Почему это критично?

1. **Спека — основа для кода.** Если она неверна, весь последующий код будет неверным.
2. **Изменить спеку до реализации в 10 раз проще**, чем рефакторить код после.
3. **Пользователь — эксперт в продукте.** Только он может подтвердить, что спека решает правильную задачу.

**Запрещено:**
- Переходить к фазе 7 без явного подтверждения.
- Делать финальный коммит без review.
- Предполагать, что "если не ответил, значит одобрил".

## Фаза 7: Финализация

Эта фаза запускается **только после подтверждения** пользователя на шаге 6.

### Шаг 7.1: Git Commit

Если на шаге 4.2 была создана Git ветка:

1. **Добавь файлы в staging:**
   ```bash
   git add .agentica/features/FT-XXXX*/
   git add .agentica/templates/ # если были изменения шаблона
   ```

2. **Создай коммит:**
   ```bash
   git commit -m "feat(spec): FT-XXXX <Название фичи>

   - Created product specification
   - Created technical specification
   - Conducted library research (if applicable)
   "
   ```

3. **Сообщи пользователю:**
   ```
   Изменения закоммичены в ветку feature/FT-XXXX-<slug>
   ```

### Шаг 7.2: Финальная валидация

Автоматически проверь созданную спецификацию:

**Checklist:**
- [ ] Файл `product.md` существует и заполнен (не содержит "TODO", "[описать позже]").
- [ ] Файл `tech.md` существует и заполнен.
- [ ] В `tech.md` есть хотя бы одна диаграмма потока данных.
- [ ] В `tech.md` указаны конкретные пути к существующим файлам (проверь наличие конкретных цитат вида `src/...`).
- [ ] Если проводился research — файл `research.md` содержит рекомендацию.
- [ ] Номер `FT-XXXX` уникален (нет дубликатов в директории).

Если хотя бы одна проверка провалена — **сообщи пользователю** и попроси разрешения исправить.

### Шаг 7.3: Отчёт пользователю

Выдай финальный отчёт:

````markdown
## ✅ Спецификация FT-XXXX создана

**Фича:** <Название фичи>
**Скоуп:** [Single-project / Package: <название>]
**Ветка:** `feature/FT-XXXX-<slug>` (если Git)

### Созданные файлы:
- ✅ `product.md` — продуктовое описание (ЧТО и ЗАЧЕМ)
- ✅ `tech.md` — техническое решение (КАК)
- ✅ `research.md` — анализ библиотек (если проводился)
- ⏳ `tasks.md` — будет заполнен через `agentica.tasks`
- ⏳ `validation.md` — будет заполнен через `agentica.tasks`

### Ключевые компоненты:
- [Компонент 1]: [краткое описание]
- [Компонент 2]: [краткое описание]

### Библиотеки:
- [Новая библиотека X] — для [назначение]
- [Существующая библиотека Y] — переиспользуется

### Риски:
- [Риск 1] — [митигация]

---

### Следующий шаг:

Запустите декомпозицию на задачи:

```
/agentica.tasks --id FT-XXXX
```

Этот агент создаст детальный план реализации (`tasks.md`) и критерии приемки (`validation.md`).

После этого можно запустить реализацию:

```
/agentica.implement --id FT-XXXX
```

Агент `implement` будет работать по задачам из `tasks.md`, а не напрямую по спецификации.
````

## Дополнительные правила

### Работа с неопределённостью

Если пользователь говорит "сделай как лучше" или "на твоё усмотрение":

1. **Проанализируй контекст:** Посмотри на существующие паттерны в коде (шаг 2).
2. **Предложи 2-3 варианта** через `ask_questions`:
   ```
   Я вижу два подхода для реализации CSV импорта:
   
   A) Синхронный парсинг (проще, но блокирует при больших файлах)
   B) Streaming парсинг (сложнее, но масштабируется)
   
   Какой подход предпочтителен?
   ```
3. **Дай рекомендацию** с обоснованием (можно пометить один вариант как `recommended`).

### Работа с конфликтами

Если новая фича конфликтует с существующим кодом:

1. **Задокументируй конфликт** в разделе "Интеграция" → "Модули, которые будут изменены" → "Риски".
2. **Предложи план разрешения:**
   - Изменить существующий код (с указанием, что именно и как).
   - Создать адаптер/обёртку для изоляции.
   - Вынести общую логику в отдельный модуль.
3. **Спроси пользователя** через `ask_questions`, какой подход применить.

### Работа с большими фичами

Если фича слишком большая (> 5 компонентов, > 3 модулей):

1. **Спроси пользователя** через `ask_questions`:
   ```
   Фича получается большой. Рекомендую разделить на несколько частей:
   
   FT-XXXX (Phase 1): Базовый импорт CSV
   FT-YYYY (Phase 2): Пакетная обработка
   FT-ZZZZ (Phase 3): Progress tracking
   
   Создать все три спеки сразу или сфокусироваться на Phase 1?
   ```

2. Если пользователь соглашается на разделение — создай только первую фичу, в конце отчёта предложи создать следующую.

### Терминология и стиль

1. **Используй термины из `tech.md`** проекта (если они есть).
2. **Пиши кратко, но точно:** Одно предложение лучше абзаца воды.
3. **Примеры кода:** TypeScript/Python-подобный (или на языке проекта) псевдокод, близкий к реальности.

### Обработка ошибок и откатов

Если на любом этапе что-то пошло не так:

1. **Сообщи пользователю** чётко и конкретно: "Не удалось [действие], причина: [объяснение]".
2. **Предложи варианты:**
   - Повторить попытку (если временная ошибка).
   - Изменить подход (если концептуальная проблема).
   - Откатить изменения (если что-то сломалось).
3. **Не оставляй проект в полусделанном состоянии:** Если нужно остановиться — удали неполную спеку, откати Git ветку.

## Итоговый Checklist

Перед завершением работы убедись:
- [ ] Определён корректный скоуп (root или конкретный пакет).
- [ ] Собран полный контекст через интервью (6 измерений).
- [ ] Просканирован существующий код, факты сохранены в memory.
- [ ] Проведён research библиотек (если требовался).
- [ ] Создана Git ветка (если есть Git).
- [ ] Скопирован и заполнен шаблон (`product.md`, `tech.md`).
- [ ] Пользователь **подтвердил** спецификацию (фаза 6).
- [ ] Изменения закоммичены в Git (если есть Git).
- [ ] Написан финальный отчёт с предложением запустить `agentica.tasks`.

Только после выполнения всех пунктов можно считать задачу завершённой.

